use {
  &0 = 'fib'
}

// func fib(n: Int): Int = do
//   if n > 1
//     fib(n - 1) + fib(n - 2)
//   else n
// end
@frame_size 2
multi fib(%0: Int): Int {
  // We have to unbox the integer argument first and save it on the frame.
  load %0
  int_unbox
  store %1
  int_push 1
  load %1
  int_less_than
  jump_if_false .else
  load %1
  int_push 1
  int_subtract
  int_box // Every time we want to call a multi-function with an integer, we have to box it.
  dispatch &0 1
  load %1
  int_push 2
  int_subtract
  int_box
  dispatch &0 1
  int_box_add // Instead of unboxing the integer values already on the stack, we can best use the boxed version of int_add.
  jump .end
  .else
  load %0
  .end
  return
}

// func test(): Int = fib(10)
@frame_size 0
multi test(): Int {
  int_box_push 10
  dispatch &0 1
  return
}
