module lore.Real

use lore.Option
use lore.Option.[Some, None]
use lore.Symbol

/**
  * Converts the given Real value to an Int by truncating the fractional part.
  */
func to_int(value: Real): Int = intrinsic[Int]('lore.real.to_int', value)

/**
  * Parses `string` as a Real value. If `string` cannot be parsed as a Real value, `None` is returned. Case insensitive
  * `'nan'`, `'inf'`, and `'-inf'` are supported as well.
  */
func parse(string: String): Option[Real] = do
  // TODO (pyramid): There should be a function `Option.from_try` for a result `A | #error`, but the problem is that
  //                 type parameters and sum/intersection types don't play nice together, yet. A middle ground would be
  //                 to use pattern matching, which is also not implemented yet. So for now we're resorting to a manual
  //                 extraction approach... Very ugly. We need pattern matching ASAP.
  let result = intrinsic[Real | #error]('lore.real.parse', string)
  result_to_option(result)
end

func result_to_option(result: Real | #error): Option[Real]
func result_to_option(result: Real): Some[Real] = Some(result)
func result_to_option(#error): None = None

func nan?(number: Real): Boolean = intrinsic[Boolean]('lore.real.nan?', number)
