//function append(list: [A], element: B): [A] where A, B <: A = dynamic[[A]]('Lore.values.list.append', list, element)
//function prepend(list: [A], element: B): [B] where A, B >: A = dynamic[[B]]('Lore.values.list.prependWiden', list, element)

// TODO: We'd have to somehow return a list of type LUB(A, B) and also propagate that type to the runtime function.
//       It'd probably be easier to just define a construction operator for lists, such as +:.
//function prepend(list: [A], element: B): [A | B] where A, B = dynamic[[A | B]]('Lore.values.list.prepend', list, element)

// Note that the append operator is defined by the compiler and thus doesn't need to be defined here.

// TODO: Rename to size to have a consistent approach to collection size? Map size should also be called size.
function length(list: [A]): Int where A = dynamic[Int]('Lore.values.list.length', list)
function get(list: [A], index: Int): A where A = dynamic[A]('Lore.values.list.get', list, index)

//function head(list: [A]): A
//function tail()
//function init()
//function last()

function stringJoin(list: [A], separator: String): String where A = {
  // TODO: Implement using init and last.
  let result = ''
  let i = 0
  let n = length(list)
  while (i < n - 1) {
    const s = toString(get(list, i))
    result = '$result$s$separator'
    i += 1
  }

  const s = if (n > 0) {
    toString(get(list, i))
  } else ''

  '[$result$s]'
}

// TODO: If we change lists to our own custom implementation, it would still be useful to expose some kind of
//       interface for Javascript arrays, just in case they are needed by the developer. This would be the place
//       to do so. However, we would first need some way to define a class whose implementation is deferred to
//       Javascript, much like dynamic calls do for functions.
//       Arrays could be typed #[T] with a constructor #[t1, t2, t3].


// TODO: Tuples need a more generic solution.
function first(tuple: (A, B)): A where A, B = dynamic[A]('Lore.values.tuple.get', tuple, 0)
function second(tuple: (A, B)): B where A, B = dynamic[B]('Lore.values.tuple.get', tuple, 1)

