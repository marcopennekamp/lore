module lore

use lore.core.[to_string, panic]
use lore.List
use lore.Enum
use lore.Enum.[map, fold]
use lore.Option
use lore.Option.[Some, None]

/**
  * Please note: This version of string handling is currently bound to the way that our target language, Javascript,
  * handles strings. In particular, the `length` of a string doesn't necessarily correspond to the number of graphemes
  * in the string, and neither does `at` always return a grapheme.
  *
  * TODO (assembly): We need to completely rewrite this module again as strings have changed going from JS to the VM.
  *                  `length` and `at!` need to work on code points, but we should also provide functions `byte_size`,
  *                  `byte_get!`, and `byte_at!` (next code point starting from the given byte index, which is a hybrid
  *                  of `at!` and `byte_get!`), as well as provide an iterator that can be used to efficiently iterate
  *                  through a string. The iterator itself can be written in Lore and should use `byte_size` and
  *                  `byte_at!`. The string's length should be cached by the VM.
  */
module String do
  /**
    * Returns the number of code units in the UTF-16 string.
    */
  func length(string: String): Int = panic('`lore.String.length` is not supported yet.')

  /**
    * Returns the code unit at the given position in the UTF-16 string. If `position` is out of range, the result is
    * the empty string.
    */
  func at!(string: String, index: Int): String = panic('`lore.String.at!` is not supported yet.')

  /**
    * Returns the code unit at the given position in the UTF-16 string. If `position` is out of range, the result is
    * `None`.
    */
  func at(string: String, index: Int): Option[String] = do
    //let result = intrinsic[String]('lore.string.at', string, index)
    //if present?(result) then Some(result) else None
    panic('`lore.String.at` is not supported yet.')
  end

  /**
    * Whether `string` is empty.
    */
  func empty?(string: String): Boolean = length(string) == 0

  /**
    * Whether `string` has at least one grapheme.
    */
  func present?(string: String): Boolean = !empty?(string)

  /**
    * Concatenates `a` and `b` into a single string.
    */
  func concat(a: String, b: String): String = '$a$b'

  /**
    * Concatenates all strings in the given list.
    *
    * TODO (pyramid): This could perhaps benefit from the performance of an intrinsic implementation.
    */
  func concat(strings: [String]): String = fold(strings, '', concat)

  /**
    * Maps `f` to all elements of `list`, producing a list of strings which is then concatenated.
    */
  @where A, B >: A
  func concat_map(list: [A], f: B => String): String = list |> map(f) |> concat

  /**
    * Joins the string representations of all elements of `list` into a string, separating them with `separator`.
    */
  func join(list: [Any], separator: String): String = do
    if Enum.empty?(list) then return ''
    concat(
      List.init(list) |> concat_map(a => '$a$separator'),
      List.last(list) |> to_string
    )
  end

  /**
    * Whether the given predicate is true for all code units of the string.
    *
    * TODO (pyramid): Functions like `all?` suggest that String should also be treated as an Enum. `at` could be
    *                 renamed to `get`.
    */
  func all?(string: String, predicate: String => Boolean): Boolean = do
    let len = length(string)
    let mut i = 0
    while i < len
      if !predicate(at!(string, i))
        return false
      end
      i += 1
    end
    true
  end

  /**
    * Prefixes `string` with `prefix` and suffixes it with `suffix`.
    */
  func affix(string: String, prefix: String, suffix: String): String = '$prefix$string$suffix'

  // TODO (pyramid): We should probably replace the following functions with regex solutions. Also look at how
  //                 fastparse solves this to keep performance high.

  /**
    * Whether the given string consists entirely of whitespace characters.
    *
    * TODO (pyramid): Rename to `all_whitespace?`.
    */
  func whitespace?(string: String): Boolean = string |> all?(c => c == ' ' || c == '\t' || c == '\n' || c == '\r')

  /**
    * Whether the given string consists entirely of digits from 0 to 9.
    *
    * TODO (pyramid): Rename to `all_digits?`.
    * TODO (pyramid): This is obviously not optimized.
    */
  func digits?(string: String): Boolean = string |> all?(c => c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9')
end

module core do
  func to_string(value: String): String = value

  // TODO (pyramid): Implement other core functions.
end
