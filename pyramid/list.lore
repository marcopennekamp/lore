module lore.list

use lore.core.panic
use lore.number.[odd?, min]
use lore.option._
use lore.sort.merge_sort

-- TODO (syntax): Use trailing lambdas for calls like `extremum!(list, (x, y) => x > y)`.

module List
  -- Creates a list that contains [element] [n] times.
  @where A
  func repeat(element: A, n: Int): [A] =
    var i = 0
    while i < n do
      i += 1
      element

-- Returns the length of [list] in constant time.
func length(list: [Any]): Int = intrinsic[Int]('lore.list.length', list)

-- Whether [list] has no elements.
func empty?(list: [Any]): Boolean = list.length == 0

-- Whether [list] has at least one element.
func present?(list: [Any]): Boolean = list.length > 0

-- Returns the element of [list] at [index]. If [index] is out of range, [get!] panics.
@where A
func get!(list: [A], index: Int): A =
  if index < 0 or index >= list.length then
    panic('Index out of bounds for `List.get!`: $index.')
  list.get_unchecked!(index)

-- The same as [get!], but without bounds checks.
@where A
func get_unchecked!(list: [A], index: Int): A = intrinsic[A]('lore.list.get', list, index)

-- Returns the element of [list] at [index]. If [index] is out of range, the result is [None].
@where A
func get(list: [A], index: Int): Option[A] =
  if index >= 0 and index < list.length
  then Some(list.get_unchecked!(index))
  else None

-- Returns the first element of [list]. Panics if the list is empty.
@where A
func head!(list: [A]): A = list.get!(0)

-- Returns the first element of [list], or [None] if the list is empty.
@where A
func head(list: [A]): Option[A] = if list.present? then Some(list.get_unchecked!(0)) else None

-- Returns the last element of [list]. Panics if the list is empty.
@where A
func last!(list: [A]): A = list.get!(list.length - 1)

-- Returns the last element of [list], or [None] if the list is empty.
@where A
func last(list: [A]): Option[A] = if list.present? then Some(list.get_unchecked!(list.length - 1)) else None

-- Returns a slice of [list] with the last element excluded. If [list] is empty, the resulting list is also empty.
@where A
func init(list: [A]): [A] = list.slice(0, list.length - 1)

-- Returns a slice of [list] with the first element excluded. If [list] is empty, the resulting list is also empty.
@where A
func tail(list: [A]): [A] = list.slice(1)

-- Concatenates [as] and [bs] into a new list.
@where A, B
func concat(as: [A], bs: [B]): [A | B] = intrinsic[[A | B]]('lore.list.concat', as, bs)

-- Concatenates all [lists].
@where A
func flatten(lists: [[A]]): [A] = intrinsic[[A]]('lore.list.flatten', lists)

-- Maps [f] over each element of [list], producing a new list.
@where A, B >: A, C
func map(list: [A], f: B => C): [C] = intrinsic[[C]]('lore.list.map', list, f)

-- Maps [f] over each element of [list] and flattens the resulting lists.
@where A, B >: A, C
func flat_map(list: [A], f: B => [C]): [C] = intrinsic[[C]]('lore.list.flat_map', list, f)

-- Calls [f] with each element of [list].
@where A, B >: A
proc each(list: [A], f: B => Unit) do
  intrinsic[Unit]('lore.list.each', list, f)

-- Creates a new list with all elements of [list] for which [predicate] is `true`.
@where A, B >: A
func filter(list: [A], predicate: B => Boolean): [A] = intrinsic[[A]]('lore.list.filter', list, predicate)

-- Folds [list] with an [initial] accumulating value, calling [f] with each element and the accumulating value.
@where A, B >: A, I, R >: I
func fold(list: [A], initial: I, f: (R, B) => R): R =
  var result: R = initial
  for element <- list do
    result = f(result, element)
  result

-- Checks whether [predicate] is true for all elements in [list].
@where A, B >: A
func all?(list: [A], predicate: B => Boolean): Boolean =
  for e <- list do
    if not predicate(e) then return false
  true

-- Creates a slice of [list] from index [start], taking [length] elements if available.
@where A
func slice(list: [A], start: Int, length: Int): [A] = intrinsic[[A]]('lore.list.slice', list, start, length)

-- Creates a slice of [list] from index [start] until the end of the list. If [start] is out of bounds, the result is
-- an empty list
@where A
func slice(list: [A], start: Int): [A] = list.slice(start, list.length)

-- Splits [list] into two lists, leaving [count] elements in the first list.
@where A
func split(list: [A], count: Int): ([A], [A]) = (
  list.slice(0, count),
  list.slice(count),
)

-- Splits [list] into two equally sized lists. If [list]'s length is odd, the odd element ends up in the first list.
@where A
func split(list: [A]): ([A], [A]) =
  if list.length.odd? then
    list.split(list.length / 2 + 1)
  else
    list.split(list.length / 2)

-- Zips elements from [as] and [bs] into a list of tuples. Spare elements of the longer list are ignored.
@where A, B
func zip(as: [A], bs: [B]): [(A, B)] =
  let mut i = 0
  let len = min(as.length, bs.length)
  while i < len do
    let a = as.get_unchecked!(i)
    let b = bs.get_unchecked!(i)
    i += 1
    (a, b)

-- Finds the smallest element in [list] using `<` for comparisons. Returns [None] if [list] is empty.
@where A
func min(list: [A]): Option[A] = if list.present? then Some(list.min!) else None

-- Finds the smallest element in [list] using `<` for comparisons. Panics if [list] is empty.
@where A
func min!(list: [A]): A = extremum!(list, lore.core.less_than?)

-- Finds the smallest element in [list], using [lt?] ("less than") for comparisons. Returns [None] if [list] is empty.
@where A, B >: A
func min(list: [A], lt?: (B, B) => Boolean): Option[A] = if list.present? then Some(list.min!(lt?)) else None

-- Finds the smallest element in [list], using [lt?] ("less than") for comparisons. Panics if [list] is empty.
@where A, B >: A
func min!(list: [A], lt?: (B, B) => Boolean): A = extremum!(list, lt?)

-- TODO (pyramid): For `min_by`/`max_by`, ensure that `by` is only called once per element so that `by` can be an
--                 expensive computation. This simplifies some use cases where otherwise intermediate structures
--                 would have to be created.

-- Finds the first element `e` in [list] for which `by(e)` is smallest when comparing with `<`. Returns [None] if
-- [list] is empty.
@where A, B >: A, C
func min_by(list: [A], by: B => C): Option[A] = if list.present? then Some(list.min_by!(by)) else None

-- Finds the first element `e` in [list] for which `by(e)` is smallest when comparing with `<`. Panics if [list] is
-- empty.
@where A, B >: A, C
func min_by!(list: [A], by: B => C): A = list.min!((x, y) => by(x) < by(y))

-- Finds the largest element in [list] using `<` for comparisons. Returns [None] if [list] is empty.
@where A
func max(list: [A]): Option[A] = if list.present? then Some(list.max!) else None

-- Finds the largest element in [list], using `<` for comparisons. Panics if [list] is empty.
@where A
func max!(list: [A]): A = extremum!(list, (x, y) => x > y)

-- Finds the largest element in [list], using [lt?] ("less than") for comparisons. Returns [None] if [list] is empty.
@where A, B >: A
func max(list: [A], lt?: (B, B) => Boolean): Option[A] = if list.present? then Some(list.max!(lt?)) else None

-- Finds the largest element in [list], using [lt?] ("less than") for comparisons. Panics if [list] is empty.
@where A, B >: A
func max!(list: [A], lt?: (B, B) => Boolean): A = extremum!(list, (x, y) => lt?(y, x))

-- Finds the first element `e` in [list] for which `by(e)` is largest when comparing with `<`. Returns [None] if [list]
-- is empty.
@where A, B >: A, C
func max_by(list: [A], by: B => C): Option[A] = if list.present? then Some(list.max_by!(by)) else None

-- Finds the first element `e` in [list] for which `by(e)` is largest when comparing with `<`. Panics if [list] is
-- empty.
@where A, B >: A, C
func max_by!(list: [A], by: B => C): A = list.max!((x, y) => by(x) < by(y))

-- Finds the extremum in [list] given a comparison function [ex?]. [ex?] should return `true` if the left argument is
-- more extreme than the other argument. Panics if [list] is empty.
--
-- TODO (pyramid): This can be a private function, as it's meant to be an implementation of `min` and `max`.
@where A, B >: A
func extremum!(list: [A], ex?: (B, B) => Boolean): A =
  if list.empty? then panic('Cannot call `lore.list.extremum!` on an empty list.')

  var result = list.get!(0)
  var i = 1
  let len = list.length
  while i < len do
    let candidate = list.get!(i)
    if ex?(candidate, result) then
      result = candidate
    i += 1
  result

-- Sorts [list] with a stable sorting algorithm, currently a merge sort, using `<` for comparisons.
@where A
func sort(list: [A]): [A] = merge_sort(list)

-- Sorts [list] with a stable sorting algorithm, currently a merge sort, using [lt?] ("less than") for comparisons.
@where A, B >: A
func sort(list: [A], lt?: (B, B) => Boolean): [A] = merge_sort(list, lt?)

-- Sorts [list] with a stable sorting algorithm, currently a merge sort, using [by] to map the list's elements to
-- values that are compared with `<`. [by] may be called multiple times for the same element.
--
-- TODO (pyramid): Ensure that [by] is only called once per element so that [by] can be an expensive computation. This
--                 simplifies some use cases where otherwise intermediate structures would have to be created.
@where A, B >: A, C
func sort_by(list: [A], by: B => C): [A] = list.sort((x, y) => by(x) < by(y))

-- Whether [list] is sorted, comparing elements with `<`.
@where A
func sorted?(list: [A]): Boolean =
  -- TODO (syntax): Ranges, ranges, ranges...
  -- We could also use a sliding window here, but that would be better solved with an iterator than a function that
  -- produces a new intermediate data structure.
  var i = 0
  let len = list.length - 1
  while i < len do
    let e1 = list.get_unchecked!(i)
    let e2 = list.get_unchecked!(i + 1)
    if e2 < e1 then return false
    i += 1
  true

-- Creates all combinatorial pairs of elements in [list]. [combinations] disregards element order, meaning that if
-- [list] contains two elements `a` and `b`, only one pair `(a, b)` or `(b, a)` will be included in the result. The
-- result is unique if all elements in [list] are distinct.
@where A
func combinations(list: [A]): [(A, A)] =
  var result: [(A, A)] = []
  var i = 0
  let len = list.length
  -- TODO (syntax): We really need iterators for this.
  while i < len do
    var j = i
    while j < len do
      result = result :+ (list.get!(i), list.get!(j))
      j += 1
    i += 1
  result
