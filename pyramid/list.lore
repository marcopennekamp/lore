module lore

module List do
  use lore.core.panic
  use lore.Enum._
  use lore.number.odd?
  use lore.Option._
  use lore.sort.merge_sort

  /**
    * Returns the element at the given index. If `index` is out of range, `get!` panics.
    */
  @where A
  func get!(list: [A], index: Int): A = do
    if index < 0 || index >= length(list)
      panic('Index out of bounds for `List.get!`: $index.')
    end
    intrinsic[A]('lore.list.get!', list, index)
  end

  /**
    * Returns the element at the given index. If `index` is out of range, the result is `None`.
    */
  @where A
  func get(list: [A], index: Int): Option[A] = do
    if index >= 0 && index < length(list) then Some(list |> get!(index)) else None
  end

  func length(list: [Any]): Int = intrinsic[Int]('lore.list.length', list)

  @where A, B
  func concat(as: [A], bs: [B]): [A | B] = intrinsic[[A | B]]('lore.list.concat', as, bs)

  /**
    * Returns the first element of the list. Results in an error if the list is empty.
    *
    * TODO (pyramid): The default `head` should return an option. We can add a second function `head!` that throws an
    *                 error instead.
    */
  @where A
  func head(list: [A]): A = get!(list, 0)

  /**
    * Returns the last element of the list. Results in an error if the list is empty.
    *
    * TODO (pyramid): The default `last` should return an option. We can add a second function `last!` that throws an
    *                 error instead.
    */
  @where A
  func last(list: [A]): A = get!(list, length(list) - 1)

  /**
    * Returns a slice of `list` that includes all elements except for the last one.
    */
  @where A
  func init(list: [A]): [A] = slice(list, 0, length(list) - 1)

  /**
    * Returns a slice of `list` that includes all elements except for the first one.
    */
  @where A
  func tail(list: [A]): [A] = slice(list, 1)

  /**
    * Creates a slice of `list` from index `start`, taking `length` elements if available.
    */
  @where A
  func slice(list: [A], start: Int, length: Int): [A] = intrinsic[[A]]('lore.list.slice', list, start, length)

  /**
    * Creates a slice of `list` from index `start` until the end of the list.
    */
  @where A
  func slice(list: [A], start: Int): [A] = slice(list, start, length(list))

  /**
    * Splits `list` into two lists, leaving `count` elements in the first list.
    */
  @where A
  func split(list: [A], count: Int): ([A], [A]) = (
    list |> slice(0, count),
    list |> slice(count),
  )

  /**
    * Splits `list` into two equally sized lists. If `list`'s length is odd, the odd element ends up in the first list.
    */
  @where A
  func split(list: [A]): ([A], [A]) = do
    if odd?(length(list))
      split(list, length(list) / 2 + 1)
    else
      split(list, length(list) / 2)
    end
  end

  /**
    * Sorts `list` with a stable sorting algorithm, currently a merge sort. The utilized comparison function is
    * `lore.core.less_than?`.
    */
  @where A
  func sort(list: [A]): [A] = merge_sort(list)

  /**
    * Creates pairs with elements from the given list of <i>distinct</i> elements. The function assumes that pairs are
    * symmetric: if the list contains two elements A and B, only one pair (A, B) or (B, A) will be included in the
    * result.
    */
  @where A
  func symmetric_pairs(list: [A]): [(A, A)] = do
    let mut result: [(A, A)] = []
    let len = length(list)
    let mut i = 0
    // TODO (syntax): We really need iterators for this.
    while i < len
      let mut j = i
      while j < len
        result = result :+ (get!(list, i), get!(list, j))
        j += 1
      end
      i += 1
    end
    result
  end

  /**
    * Creates a list that contains `element` `n` times.
    */
  @where A
  func repeat(element: A, n: Int): [A] = do
    let mut i = 0
    while i < n
      i += 1
      element
    end
  end
end

/**
  * Enum provides functions for finite collections, of which lists are the most basic one.
  */
module Enum do
  use lore.List._

  func size(list: [Any]): Int = List.length(list)

  func empty?(list: [Any]): Boolean = size(list) == 0
  func present?(list: [Any]): Boolean = !empty?(list)

  @where A
  func flatten(lists: [[A]]): [A] = intrinsic[[A]]('lore.list.flatten', lists)

  @where A, B >: A, C
  func map(list: [A], f: B => C): [C] = intrinsic[[C]]('lore.list.map', list, f)

  @where A, B >: A, C
  func flat_map(list: [A], f: B => [C]): [C] = intrinsic[[C]]('lore.list.flat_map', list, f)

  @where A, B >: A
  act each(list: [A], f: B => Unit) do
    intrinsic[Unit]('lore.list.each', list, f)
  end

  @where A, B >: A
  func filter(list: [A], predicate: B => Boolean): [A] = intrinsic[[A]]('lore.list.filter', list, predicate)

  @where A, B >: A, I, R >: I
  func fold(list: [A], initial: I, f: (R, B) => R): R = do
    let mut result: R = initial
    for element <- list
      result = f(result, element)
    end
    result
  end
end
