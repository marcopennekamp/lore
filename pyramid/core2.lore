// TODO (assembly): This file only exists to allow simple examples to compile before we implement all assembly features.

module lore.core

// TODO (pyramid): Equality should be restricted to a trait Equality. Global equality is a bad idea, as it fails
//                 silently, because `equal?` can always fall back to the Any/Any function. The same issue applies to
//                 `less_than?`, which should be locked behind a trait Order.
//                 Of course, this and other traits defined in Core need proper support for providing "implementations"
//                 for traits, unless we want to hardcode these traits into the compiler. We will also have to provide
//                 a means with which a standard implementation can be derived for Equality, Order, and Showable. And
//                 finally, there need to be standard implementations for lists, maps, etc.

/**
  * The default "equals" function used by the compiler for comparing complex types. This function is invoked when using
  * the == and != operators.
  */
func equal?(a: Any, b: Any): Boolean = panic('Not supported yet.') // dynamic[Boolean]('Lore.values.areEqual', a, b)

/**
 * The default "less than" function used by the compiler for comparing complex types. This function is invoked when
 * using the < and > operators.
 */
func less_than?(a: Any, b: Any): Boolean = panic('Not supported yet.') // dynamic[Boolean]('Lore.values.isLessThan', a, b)

/**
 * The default "less than or equal" function used by the compiler for comparing complex types. This function is invoked
 * when using the <= and >= operators. By default, `less_than?` and `equal?` are used to test the values, but this
 * behavior can be implemented more efficiently for specialized types.
 */
func less_than_equal?(a: Any, b: Any): Boolean = less_than?(a, b) || equal?(a, b)

// TODO (pyramid): Restrict hashes to a Hashable label type. This would provide better safety when using maps. More
//                 often than not, especially when maps are easy to create, proper hash-ability of a type gets
//                 overlooked and keys are used recklessly. It's much better to require a programmer to explicitly
//                 declare hash-ability.

/**
 * Computes a hash from any given value. This is used by the compiler to implement maps. The standard implementation
 * defers the computation to the Javascript runtime and works for any sort of value.
 *
 * TODO (pyramid): Consider adding a second parameter that represents partially computed hashes or hash state, a
 *                 technique which Julia and Rust seem to follow.
 */
func hash(value: Any): Int = panic('Not supported yet.') // dynamic[Int]('Lore.values.hash', value)

// TODO (pyramid): Restrict `to_string` to a Showable/ToString label type so that only types for which `to_string` is
//                 explicitly implemented can be used in string interpolation.

/**
 * Converts any Lore value to a string using Javascript's native stringifier. You can specialize this function to
 * stringify your own custom types. This function is used by library functions such as `println`, as well as string
 * interpolation.
 */
func to_string(value: Any): String = panic('Not supported yet.') // dynamic[String]('Lore.values.toString', value)

/**
  * A run-time type. The struct type that backs this trait is defined ad-hoc in the runtime. Various introspection
  * functions such as `type_of` and `subtype?` work with Types.
  */
trait Type

/**
  * Returns the run-time type of the given Lore value.
  */
//func type_of(value: Any): Type = panic('Not supported yet.') // dynamic[Type]('Lore.types.introspection.typeOf', value)

/**
  * Whether `t1` is a subtype of `t2`.
  */
//func subtype?(t1: Type, t2: Type): Boolean = panic('Not supported yet.') // dynamic[Boolean]('Lore.types.introspection.isSubtype', t1, t2)

/**
  * Terminates the Lore program with the given message.
  *
  * This is a TEMPORARY measure as long as Lore doesn't support exception handling.
  */
func panic(message: String): Nothing = dynamic[Nothing]('lore.core.panic') // dynamic[Nothing]('lore.core.panic', message)
