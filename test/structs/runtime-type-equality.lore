// This example demonstrates that struct types bearing the same name may not always be equal or subtypes of each
// other at run-time. This has implications on the use of type parameters, where the run-time type matters most.
// A Lore programmer should be aware of these "quirks".
// Note that this behavior is not by design. We have to achieve consistent type equality and subtyping at run-time.
// These operations are defined without any regards to the "outside world" and shouldn't be changed because some
// other part of the system would benefit from a rule change.

trait Material
struct Leather() extends Material
struct Cloth() extends Material

struct Bag
  open material: Material
end

func equal_types?(A, B): Boolean where A, B = false
func equal_types?(A, A): Boolean where A = true

func subtype?(A, B): Boolean where A, B = false
func subtype?(A, B): Boolean where A, B <: A = true

func test(): [Boolean] = do
  let leather_bag = Bag(Leather())
  let cloth_bag = Bag(Cloth())

  [
    equal_types?(leather_bag, leather_bag),   // --> true
    equal_types?(cloth_bag, cloth_bag),       // --> true
    equal_types?(leather_bag, cloth_bag),     // --> false
    equal_types?(cloth_bag, leather_bag),     // --> false
    subtype?(leather_bag, leather_bag),       // --> true
    subtype?(cloth_bag, cloth_bag),           // --> true
    subtype?(leather_bag, cloth_bag),         // --> false
    subtype?(cloth_bag, leather_bag),         // --> false
  ]
end
