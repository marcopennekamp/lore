// This example demonstrates that struct types bearing the same name may not always be equal or subtypes of each
// other at run-time. This has implications on the use of type parameters, where the run-time type matters most.
// A Lore programmer should be aware of these "quirks".
// Note that this behavior is not by design. We have to achieve consistent type equality and subtyping at run-time.
// These operations are defined without any regards to the "outside world" and shouldn't be changed because some
// other part of the system would benefit from a rule change.

trait Material
struct Leather() extends Material
struct Cloth() extends Material

struct Bag
  open material: Material
end

func equalTypes(A, B): Boolean where A, B = false
func equalTypes(A, A): Boolean where A = true

func subtype(A, B): Boolean where A, B = false
func subtype(A, B): Boolean where A, B <: A = true

func test(): [Boolean] = do
  let leatherBag = Bag(Leather())
  let clothBag = Bag(Cloth())

  [
    equalTypes(leatherBag, leatherBag),   // --> true
    equalTypes(clothBag, clothBag),       // --> true
    equalTypes(leatherBag, clothBag),     // --> false
    equalTypes(clothBag, leatherBag),     // --> false
    subtype(leatherBag, leatherBag),      // --> true
    subtype(clothBag, clothBag),          // --> true
    subtype(leatherBag, clothBag),        // --> false
    subtype(clothBag, leatherBag)         // --> false
  ]
end
