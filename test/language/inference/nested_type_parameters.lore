module language.inference

use lore.option._

// TODO (multi-import): IS THIS EVEN A PROBLEM? The basic gist is that type variables from nested constructors, for
//                      example, MIGHT conflict because they are not made unique per call. The previous algorithm would
//                      replace type variables with inference variables, which were effectively unique.
//                      An easy way to test this: Turn InferenceVariable equality into UniqueKey equality based on
//                      TypeVariable unique keys. If tests fail, the TypeVariable-only solution wouldn't work.

// TODO (multi-import): Write description. (Basically, constructor call inference must handle different occurrences of
//                      the same type variable correctly. This is quite complex. I don't even know right know whether
//                      this test is actually correct. Needs further thought and testing.)
spec 'nested_type_parameters: ???' do
  // Some[A](
  //   Some[A](x => x + 1)
  // )
  //
  // check Some(Some(x => x + 1)) :: Option[Option[Int => Int]]
  //   infer argument: Some(x => x + 1)   --- can't infer
  //   check expected output type: A = Option[Int => Int]
  //   check untyped argument: Some(x => x + 1) :: Option[Int => Int]
  //      ... this seems to work


  //val option: Option[Option[Int => Int]] = Some(Some(x => x + 1))
  // TODO (multi-import): Check the value or something.


  // How about this:
  // struct Nested[A]
  //   property: A => Nested[A] = a => Nested(a)
  // end
  //
  // Inference:
  // check a => Nested(a) :: A1 => Nested[A1]
  //   assign a :: A1
  //   check Nested[A2](a) :: Nested[A1]:
  //     infer argument: a :: A
  //     check expected output type: A2 = A1  --- because there is no distinction between A1 and A2, we have A assigned
  //                                              to itself! Does this cause any problems for inference?
  //
end
