/**
 * Imagine a situation in which we want to save a struct. We have a macro that generates an implementation of a
 * function `save` as long as all the properties of the given struct can already be dispatched to some concrete
 * function of the `save` multi-function and the struct itself extends the trait `Savable`.
 *
 * One of the properties of the struct `Character` is `ExternalPhysics`, which is defined outside our own code in
 * a library which we don't want to modify. Unfortunately, `ExternalPhysics` does not extend the Savable interface.
 *
 * Because Lore is awesome and does not force us to implement an "interface" to add functions to a multi-function,
 * our code generator can do the following:
 *
 *   1. For each property a: A that is to be saved, check if A <: Savable.
 *   2. If A is Savable, simply call `save(a)`.
 *   3. Otherwise, check if we can dispatch the call `save(a)` regardless. If this is the case, we also call
 *      `save(a)`.
 *
 * Of course, this approach will not allow us to treat ExternalPhysics as a Savable. The function call is simply
 * generated given enough type knowledge. We might at some point add a means to extend traits and structs apart from
 * their point of declaration. Another solution might be dynamic specialization. Both of these potential features
 * haven't been planned out yet, so giving an example would at this point be impossible.
 */

// Let's assume that ExternalPhysics is defined in an external library and cannot just extend Savable.
struct ExternalPhysics


// The result of the save is currently a list of things. Obviously this would be more sensible in the "real world".
trait Savable
func save(Savable): [Any]
func save(value: Real): [Any] = [value]


// A standard 2D position that can be saved.
struct Position(x: Real, y: Real) extends Savable

// The following function will be generated by the Savable code generator / macro. This is not an existing feature of
// Lore, of course, just an example. Just to be clear: we won't have a macro system for a while.
func save(pos: Position): [Any] = flatten([['Position'], save(pos.x), save(pos.y)])


// Assuming that ExternalPhysics isn't Savable, we define the following action.
func save(ExternalPhysics): [Any] = ['ExternalPhysics', 42]


struct Character extends Savable {
  position: Position
  physics: ExternalPhysics
}

func save(char: Character): [Any] = flatten([['Character'], save(char.position), save(char.physics)])


func test(): [Any] = save(Character(Position(1.5, 2.7), ExternalPhysics()))
