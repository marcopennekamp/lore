trait Combatant extends +Stats, +StatusEffects

func name(Combatant): String

/**
 * This is called once at the beginning of combat to give each combatant a chance to prepare.
 */
act enter_combat(Combatant) do end

act on_hit(combatant: Combatant) do
  on_hit_status_effects(combatant)
end

func stat(combatant: Combatant, stat_label: StatLabelInt): Int = stat_impl(combatant, stat_label, base_stat(combatant, stat_label))
func stat(combatant: Combatant, stat_label: StatLabelReal): Real = stat_impl(combatant, stat_label, base_stat(combatant, stat_label))

@where A
func stat_impl(combatant: Combatant, stat_label: StatLabel, base: A): A = do
  fold(
    combatant.status_effects.effects,
    base,
    (result: A, effect) => affect_stat(effect, stat_label, result)
  )
end


trait SimulationResult
struct SimulationVictory(winner: Combatant) extends SimulationResult
struct SimulationStalemate() extends SimulationResult

act combat_log(message: String) do
  //println(message)
end

/**
 * Simulate the combat between two combatants using a turn-based algorithm. The left combatant has the initiative
 * and gets to take their turns first.
 *
 * Returns the winner of the engagement.
 */
func simulate_combat(left: Combatant, right: Combatant): SimulationResult = do
  let mut turn = 1
  let mut distance = 8

  enter_combat(left)
  enter_combat(right)

  let left_state = CombatantState { combatant = left }
  let right_state = CombatantState { combatant = right }

  while alive?(left) && alive?(right)
    combat_log('Turn $turn:')

    // Phase 1: Closing the distance.
    if distance > 0
      distance = close_distance(left, distance)
      distance = close_distance(right, distance)
    end

    // Phase 2: Attack phase.
    attempt_attack(left_state, right_state, distance)
    attempt_attack(right_state, left_state, distance)

    // Phase 3: Post-attack regeneration and status effect updates.
    update_combatant_post_attack(left)
    update_combatant_post_attack(right)

    combat_log('${name(left)} health: ${left.stats.health}')
    combat_log('${name(right)} health: ${right.stats.health}')

    turn += 1

    combat_log('')
  end

  if alive?(left) && !alive?(right)
    combat_log('${name(left)} wins the battle!')
    SimulationVictory(left)
  end else if !alive?(left) && alive?(right)
    combat_log('${name(right)} wins the battle!')
    SimulationVictory(right)
  end else
    combat_log('We have a stalemate between ${name(left)} and ${name(right)}!')
    SimulationStalemate()
  end
end

struct CombatantState
  combatant: Combatant
  mut dodge: Real = 0.0
end

/**
 * Whether the combatant is in range to attack, based on the entity's range stat.
 */
func in_range?(combatant: Combatant, distance: Int): Boolean = stat(combatant, #range) >= distance

/**
 * Closes the given distance to the other combatant, provided the given combatant isn't already in range.
 */
func close_distance(combatant: Combatant, distance: Int): Int = do
  if distance > 0 && !in_range?(combatant, distance)
    let new = max(distance - stat(combatant, #speed), 0)
    combat_log('${name(combatant)} closes distance to $new.')
    new
  end else distance
end

/**
 * Performs dodge calculations for the given state and returns whether the current attempt succeeded. This function
 * has side effects.
 */
func attempt_dodge(state: CombatantState): Boolean = do
  state.dodge += stat(state.combatant, #dodge)
  if state.dodge >= 1.0
    combat_log('${name(state.combatant)} dodges an attack.')
    state.dodge -= 1.0
    true
  end else false
end

act attempt_attack(attacker_state: CombatantState, defender_state: CombatantState, distance: Int) do
  if in_range?(attacker_state.combatant, distance)
    let dodged? = attempt_dodge(defender_state)
    if !dodged?
      let attack = stat(attacker_state.combatant, #attack)
      hit(attacker_state.combatant, defender_state.combatant, attack)
    end
  end
end

/**
 * Damages a target, taking into account defense but not dodge. Also triggers on_hit calls.
 */
act hit(source: Combatant, target: Combatant, damage: Int) do
  let defense = stat(target, #defense)
  let damage_after_defense = max(damage - defense, 0)
  combat_log('${name(source)} attacks ${name(target)} for $damage_after_defense damage given a defense of $defense.')
  target.stats.health -= damage_after_defense
  on_hit(target)
end

/**
 * Performs post-attack regeneration and status effect updates provided the combatant is still alive.
 */
act update_combatant_post_attack(combatant: Combatant) do
  if alive?(combatant)
    heal(combatant, stat(combatant, #regeneration))
    update_status_effects(combatant)
  end
end

act heal(target: Combatant, amount: Int) do
  let stats = target.stats
  let old_health = stats.health
  stats.health = min(stats.health + amount, stats.maximum_health)
  if stats.health > old_health
    combat_log('${name(target)} is healed by ${stats.health - old_health} points.')
  end
end
