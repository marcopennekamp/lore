trait Combatant extends +Stats, +StatusEffects

func name(Combatant): String

/**
 * This is called once at the beginning of combat to give each combatant a chance to prepare.
 */
act enterCombat(Combatant) do
end

act onHit(combatant: Combatant) do
  onHitStatusEffects(combatant)
end

func stat(combatant: Combatant, statLabel: StatLabelInt): Int = statImpl(combatant, statLabel, baseStat(combatant, statLabel))
func stat(combatant: Combatant, statLabel: StatLabelReal): Real = statImpl(combatant, statLabel, baseStat(combatant, statLabel))

func statImpl(combatant: Combatant, statLabel: StatLabel, base: A): A where A = do
  fold(
    combatant.statusEffects.effects,
    base,
    (result: A, effect) => affectStat(effect, statLabel, result)
  )
end


trait SimulationResult
struct SimulationVictory(winner: Combatant) extends SimulationResult
struct SimulationStalemate() extends SimulationResult

act combatLog(message: String) do
  println(message)
end

/**
 * Simulate the combat between two combatants using a turn-based algorithm. The left combatant has the initiative
 * and gets to take their turns first.
 *
 * Returns the winner of the engagement.
 */
func simulateCombat(left: Combatant, right: Combatant): SimulationResult = do
  let mut turn = 1
  let mut distance = 8

  enterCombat(left)
  enterCombat(right)

  let leftState = CombatantState { combatant = left }
  let rightState = CombatantState { combatant = right }

  while isAlive(left) && isAlive(right)
    combatLog('Turn $turn:')

    // Phase 1: Closing the distance.
    if distance > 0
      distance = closeDistance(left, distance)
      distance = closeDistance(right, distance)
    end

    // Phase 2: Attack phase.
    attemptAttack(leftState, rightState, distance)
    attemptAttack(rightState, leftState, distance)

    // Phase 3: Post-attack regeneration and status effect updates.
    updateCombatantPostAttack(left)
    updateCombatantPostAttack(right)

    combatLog('${name(left)} health: ${left.stats.health}')
    combatLog('${name(right)} health: ${right.stats.health}')

    turn += 1

    combatLog('')
  end

  if isAlive(left) && !isAlive(right)
    combatLog('${name(left)} wins the battle!')
    SimulationVictory(left)
  end else if !isAlive(left) && isAlive(right)
    combatLog('${name(right)} wins the battle!')
    SimulationVictory(right)
  end else
    combatLog('We have a stalemate between ${name(left)} and ${name(right)}!')
    SimulationStalemate()
  end
end

struct CombatantState
  combatant: Combatant
  mut dodge: Real = 0.0
end

/**
 * Whether the combatant is in range to attack, based on the entity's range stat.
 */
func isInRange(combatant: Combatant, distance: Int): Boolean = stat(combatant, #range) >= distance

/**
 * Closes the given distance to the other combatant, provided the given combatant isn't already in range.
 */
func closeDistance(combatant: Combatant, distance: Int): Int = do
  if distance > 0 && !isInRange(combatant, distance)
    let new = max(distance - stat(combatant, #speed), 0)
    combatLog('${name(combatant)} closes distance to $new.')
    new
  end else distance
end

/**
 * Performs dodge calculations for the given state and returns whether the current attempt succeeded. This function
 * has side effects.
 */
func attemptDodge(state: CombatantState): Boolean = do
  state.dodge += stat(state.combatant, #dodge)
  if state.dodge >= 1.0
    combatLog('${name(state.combatant)} dodges an attack.')
    state.dodge -= 1.0
    true
  end else false
end

act attemptAttack(attackerState: CombatantState, defenderState: CombatantState, distance: Int) do
  if isInRange(attackerState.combatant, distance)
    let dodgeSuccessful = attemptDodge(defenderState)
    if !dodgeSuccessful
      let attack = stat(attackerState.combatant, #attack)
      hit(attackerState.combatant, defenderState.combatant, attack)
    end
  end
end

/**
 * Damages a target, taking into account defense but not dodge. Also triggers onHit calls.
 */
act hit(source: Combatant, target: Combatant, damage: Int) do
  let defense = stat(target, #defense)
  let damageAfterDefense = max(damage - defense, 0)
  combatLog('${name(source)} attacks ${name(target)} for $damageAfterDefense damage given a defense of $defense.')
  target.stats.health -= damageAfterDefense
  onHit(target)
end

/**
 * Performs post-attack regeneration and status effect updates provided the combatant is still alive.
 */
act updateCombatantPostAttack(combatant: Combatant) do
  if isAlive(combatant)
    heal(combatant, stat(combatant, #regeneration))
    updateStatusEffects(combatant)
  end
end

act heal(target: Combatant, amount: Int) do
  let stats = target.stats
  let oldHealth = stats.health
  stats.health = min(stats.health + amount, stats.maximumHealth)
  if stats.health > oldHealth
    combatLog('${name(target)} is healed by ${stats.health - oldHealth} points.')
  end
end
