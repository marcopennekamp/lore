module combat.Simulation

use lore.IO.println
use lore.Math

use combat.combatants.Combatant
use combat.effects._

trait Result
struct Victory(winner: Combatant) extends Result
struct Stalemate(left: Combatant, right: Combatant) extends Result

module Result do
  act log(Result)
  act log(result: Victory) do
    combat.Simulation.log('${Combatant.name(result.winner)} wins the battle!')
  end
  act log(result: Stalemate) do
    combat.Simulation.log('We have a stalemate between ${Combatant.name(result.left)} and ${Combatant.name(result.right)}!')
  end
end

struct CombatantState
  combatant: Combatant
  mut health: Real
  mut dodge: Real = 0.0
end

/**
 * Simulate the combat between two combatants using a turn-based algorithm. The left combatant has the initiative
 * and gets to take their turns first.
 *
 * Returns the winner of the engagement.
 */
func simulate(left: Combatant, right: Combatant): Result = do
  let mut turn = 1
  let mut distance = 8

  Combatant.enter_combat(left)
  Combatant.enter_combat(right)

  let left_state = CombatantState { combatant = left, health = left.stats.maximum_health }
  let right_state = CombatantState { combatant = right, health = right.stats.maximum_health }

  while alive?(left_state) && alive?(right_state)
    log('Turn $turn:')

    // Phase 1: Closing the distance.
    if distance > 0
      distance = close_distance(left, distance)
      distance = close_distance(right, distance)
    end

    // Phase 2: Attack phase.
    attempt_attack(left_state, right_state, distance)
    attempt_attack(right_state, left_state, distance)

    // Phase 3: Updates at the end of the turn.
    end_turn(left_state)
    end_turn(right_state)

    log('${Combatant.name(left)} health: ${left_state.health}')
    log('${Combatant.name(right)} health: ${right_state.health}')

    turn += 1

    log('')
  end

  let result = cond
    alive?(left_state) && !alive?(right_state) => Victory(left)
    !alive?(left_state) && alive?(right_state) => Victory(right)
    true                                       => Stalemate(left, right)
  end

  Result.log(result)
  result
end

/**
  * Whether the combatant is alive.
  */
func alive?(state: CombatantState): Boolean = state.health > 0

/**
 * Whether the combatant is in range to attack, based on the entity's range stat.
 */
func in_range?(combatant: Combatant, distance: Int): Boolean = Combatant.stat(combatant, #range) >= distance

/**
 * Closes the given distance to the other combatant, provided the given combatant isn't already in range.
 */
func close_distance(combatant: Combatant, distance: Int): Int = do
  if distance > 0 && !in_range?(combatant, distance)
    let new = Math.max(distance - Combatant.stat(combatant, #speed), 0)
    log('${Combatant.name(combatant)} closes distance to $new.')
    new
  else distance
end

/**
 * Performs dodge calculations for the given state and returns whether the current attempt succeeded. This function
 * has side effects.
 */
func attempt_dodge(state: CombatantState): Boolean = do
  state.dodge += Combatant.stat(state.combatant, #dodge)
  if state.dodge >= 1.0
    log('${Combatant.name(state.combatant)} dodges an attack.')
    state.dodge -= 1.0
    true
  else false
end

act attempt_attack(attacker_state: CombatantState, defender_state: CombatantState, distance: Int) do
  if in_range?(attacker_state.combatant, distance)
    let dodged? = attempt_dodge(defender_state)
    if !dodged?
      let attack = Combatant.stat(attacker_state.combatant, #attack)
      hit(attacker_state, defender_state, attack)
    end
  end
end

/**
 * Damages a target, taking into account defense but not dodge. Also triggers on_hit calls.
 */
act hit(source: CombatantState, target: CombatantState, damage: Int) do
  let defense = Combatant.stat(target.combatant, #defense)
  let damage_after_defense = Math.max(damage - defense, 0)
  log('${Combatant.name(source.combatant)} attacks ${Combatant.name(target.combatant)} for $damage_after_defense damage given a defense of $defense.')
  target.health -= damage_after_defense
  Combatant.on_hit(target.combatant)
end

/**
 * Performs post-attack regeneration and status effect updates provided the combatant is still alive.
 */
act end_turn(state: CombatantState) do
  if alive?(state)
    heal(state, Combatant.stat(state.combatant, #regeneration))
    StatusEffects.update(state.combatant)
  end
end

act heal(target: CombatantState, amount: Int) do
  let old_health = target.health
  target.health = Math.min(target.health + amount, target.combatant.stats.maximum_health)
  if target.health > old_health
    log('${Combatant.name(target.combatant)} is healed by ${target.health - old_health} points.')
  end
end

act log(message: String) do
  //println(message)
end
