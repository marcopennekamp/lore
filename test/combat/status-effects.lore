trait StatusEffect

domain StatusEffect
  /**
   * Applies the status effect to the stat identified with the given label.
   */
  func affect_stat(StatLabel, value: A): A where A = value

  /**
   * Whether the status effect is active.
   */
  func active?(): Boolean = true

  /**
   * Called during the end-of-turn status effect update.
   */
  act on_update() do end

  /**
   * Called whenever the owning entity of the status effect gets hit by an attack (after a potential dodge failed).
   */
  act on_hit() do end
end


struct DurationLimit
  mut duration: Int
end

type +DurationLimit = StatusEffect & %{ limit: DurationLimit }

domain effect: +DurationLimit
  func active?(): Boolean = effect.limit.duration > 0

  act on_update() do
    if active?(effect)
      effect.limit.duration -= 1
    end
  end
end


struct HitLimit
  mut hits: Int
end

type +HitLimit = StatusEffect & %{ limit: HitLimit }

domain effect: +HitLimit
  func active?(): Boolean = effect.limit.hits > 0

  act on_hit() do
    if active?(effect)
      effect.limit.hits -= 1
    end
  end
end


/**
 * The entity is armored and has increased defense. The armor breaks after a set amount of hits.
 */
struct Armored extends StatusEffect
  armor: Int
  limit: HitLimit
end

func create_armored(armor: Int, durability: Int): Armored = Armored(armor, HitLimit(durability))

domain effect: Armored
  func affect_stat(#defense, value: Int): Int = value + effect.armor
end


/**
 * The entity is infused with Stormlight.
 */
struct Infusion extends StatusEffect
  limit: DurationLimit
end

func create_infusion(duration: Int): Infusion = Infusion(DurationLimit(duration))

domain effect: Infusion
  func affect_stat(#attack | #speed, value: Int): Int = floor(value * 1.5)
  func affect_stat(#dodge, value: Real): Real = 1.0 // Dodge all attacks while infused.
  func affect_stat(#regeneration, value: Int): Int = 5
end


struct StatusEffects
  mut effects: [StatusEffect]
end

type +StatusEffects = %{ status_effects: StatusEffects }

domain entity: +StatusEffects
  act buff(effect: StatusEffect) do
    entity.status_effects.effects = entity.status_effects.effects :+ effect
  end

  /**
   * Updates status effects, removing those from the list that have expired.
   */
  act update_status_effects() do
    let effects = entity.status_effects.effects
    effects |> each(on_update)
    entity.status_effects.effects = effects |> filter(active?)
  end

  act on_hit_status_effects() do
    for effect <- entity.status_effects.effects
      on_hit(effect)
    end
  end
end
