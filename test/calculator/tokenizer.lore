module Tokenizer

use lore.Enum.[map, empty?]
use lore.IO.println
use lore.Number
use lore.Option
use lore.Option.[Some, None, or_else]
use lore.String
use lore.Tuple

use Token.[Operand, Operator]

type Position = Int

func tokenize(term: String): Option[[Token]] = do
  let mut position = 0
  let mut tokens: [Token] = []
  let term_length = String.length(term)

  while position < term_length
    position = skip_whitespace(term, position)

    let result_tuple_option =
      try_operand(term, position)
        |> or_else(() => try_operator(term, position))

    // TODO (case): This could be pattern-matched. Alternatively, we could support non-local returns in anonymous
    //              functions and write `|> get_or_else(() => return None)`.
    if empty?(result_tuple_option)
      return None
    end

    // TODO (case): This is a little awkward due to missing destruction of tuples.
    // It could read: `(let token, position) = result` or `let (token, ^position) = result` without the assignment
    // pattern matching.
    let result_tuple = Option.get(result_tuple_option)
    let token = Tuple.first(result_tuple)
    tokens = tokens :+ token
    position = Tuple.second(result_tuple)
  end

  Some(tokens)
end

func skip_whitespace(term: String, position: Position): Position = do
  let mut pos = position
  let term_length = String.length(term)
  while pos < term_length && String.force_at(term, pos) |> String.whitespace?
    pos += 1
  end
  pos
end

func try_operand(term: String, position: Position): Option[(Operand, Position)] = do
  let mut number_string = ''
  let mut pos = position
  let term_length = String.length(term)

  while pos < term_length && String.force_at(term, pos) |> String.digits?
    number_string = String.concat(number_string, String.force_at(term, pos))
    pos += 1
  end

  // If not a single digit has been parsed, `Number.parse` will consume the empty string and return None.
  // TODO (syntax): This is essentially a trailing lambda.
  number_string |> Number.parse |> map(number => do
    let operand = Operand(number)
    (operand, pos)
  end)
end

func try_operator(term: String, position: Position): Option[(Operator, Position)] = do
  let char = String.force_at(term, position)

  // TODO (case): This could be a case expression.
  let operator = cond
    char == '+' => Operator.Add
    char == '-' => Operator.Sub
    char == '*' => Operator.Mul
    char == '/' => Operator.Div
    true        => return None
  end

  Some((operator, position + 1))
end
