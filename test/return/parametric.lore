struct Position { x: Real = 0, y: Real = 0, z: Real = 0 }

func toString(position: Position): String = '{ x = ${position.x}, y = ${position.y}, z = ${position.z} }'


// TODO: Make it so that we can work directly on +Position instead of having to declare a Movable trait. This
//       would require shape types to support mutable properties, though.
trait Movable

func position(movable: Movable): Position
action setPosition(movable: Movable, position: Position)

action move(movable: Movable, x: Real, y: Real, z: Real) {
  let old = position(movable)
  let position = Position(old.x + x, old.y + y, old.z + z)
  setPosition(movable, position)
}


struct Zombie extends Movable {
  name: String
  mut position: Position = Position { }
}

func position(zombie: Zombie): Position = zombie.position
action setPosition(zombie: Zombie, position: Position) {
  zombie.position = position
}

func toString(zombie: Zombie): String = '${zombie.name} is at position ${zombie.position}'


func update(a: A): A where A = a

// This is essentially a way to test that the compiler and runtime correctly handle returning an argument that
// doesn't have a concrete type at compile-time.
func update(a: A): A where A <: Movable = {
  move(a, 1.7, 1.5, 0)
  a
}

func test(): Zombie = {
  let zombie = Zombie { name = 'Fred', position = Position(0, 1.0, 0.5) }
  let updatedZombie: Zombie = update(zombie)
  updatedZombie
}
