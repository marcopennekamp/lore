struct Position(x: Real = 0, y: Real = 0, z: Real = 0)

func to_string(position: Position): String = '{ x = ${position.x}, y = ${position.y}, z = ${position.z} }'


// TODO: Make it so that we can work directly on +Position instead of having to declare a Movable trait. This
//       would require shape types to support mutable properties, though.
trait Movable

func position(Movable): Position
act set_position(Movable, Position)

act move(movable: Movable, x: Real, y: Real, z: Real) do
  let old = position(movable)
  let position = Position(old.x + x, old.y + y, old.z + z)
  set_position(movable, position)
end


struct Zombie extends Movable
  name: String
  mut position: Position = Position { }
end

func position(zombie: Zombie): Position = zombie.position
act set_position(zombie: Zombie, position: Position) do
  zombie.position = position
end

func to_string(zombie: Zombie): String = '${zombie.name} is at position ${zombie.position}'


func update(a: A): A where A = a

// This is essentially a way to test that the compiler and runtime correctly handle returning an argument that
// doesn't have a concrete type at compile-time.
@where A <: Movable
func update(a: A): A = do
  move(a, 1.7, 1.5, 0)
  a
end

func test(): Zombie = do
  let zombie = Zombie { name = 'Fred', position = Position(0, 1.0, 0.5) }
  let updated_zombie = update(zombie)
  updated_zombie
end
