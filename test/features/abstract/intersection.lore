module features.abstract.intersection

trait T1
trait T2
trait U
trait U1 extends U
trait U2 extends U
trait V
trait V1 extends V
trait W
trait W1 extends W

struct A extends T1, V
  name: String
end
object B extends T2, U1, V1, W1
struct C extends T1, T2, U2
  name: String
end

func f1(T1): String
func f1(A): String = 'A'
func f1(C): String = 'C'

func f2(T2): String
func f2(B): String = 'B'
func f2(C): String = 'C'

func f3(T1 & T2): String
func f3(C): String = 'C'

func f4(T2 & U): String
func f4(B): String = 'B'
func f4(C): String = 'C'

func f5(U): String
func f5(B): String = 'B'
func f5(C): String = 'C'

func f6(U & V): String
func f6(B): String = 'B'

func f7(V & %{ name: String }): String
func f7(A): String = 'A'

func f8(U & %{ name: String }): String
func f8(C): String = 'C'

// Note that `W1 & %{ name: String }` has no concrete subtypes and thus doesn't need to be implemented at all.
func f9(W1 & %{ name: String }): String

trait X
trait Y
struct X1() extends X, Y
struct X2() extends X, Y
struct X3() extends X, Y
struct X4() extends X
struct Y1() extends Y

func f10(X & Y): String
func f10(X1 | X2): String = 'X1|X2'
func f10(X3): String = 'X3'

@root
module features.abstract do
  use lore.test._

  spec 'intersection: dispatch with intersection types should return the correct values' do
    let a = A('Ada')
    let b = B
    let c = C('Cone')

    assert_equal(f1(a), 'A')
    assert_equal(f1(c), 'C')
    assert_equal(f2(b), 'B')
    assert_equal(f2(c), 'C')
    assert_equal(f3(c), 'C')
    assert_equal(f4(b), 'B')
    assert_equal(f4(c), 'C')
    assert_equal(f5(b), 'B')
    assert_equal(f5(c), 'C')
    assert_equal(f6(b), 'B')
    assert_equal(f7(a), 'A')
    assert_equal(f8(c), 'C')
    assert_equal(f10(X1()), 'X1|X2')
    assert_equal(f10(X2()), 'X1|X2')
    assert_equal(f10(X3()), 'X3')
  end
end
