trait Element
trait Fire extends Element
trait Ice extends Element
trait Earth extends Element

trait Cost
trait Mana extends Cost
trait Stamina extends Cost
trait Health extends Cost

trait Specialty
trait Freezing extends Specialty
trait Penetrating extends Specialty

type Defense = Int
type Damage = Int


trait Spell[+E <: Element, +C <: Cost]

func rawDamage(Spell[Element, Cost]): Damage
func damageOf(Spell[Element, Cost], Defense): Damage


trait Spike[+E <: Ice | Earth, +S <: Specialty, +Id] extends Spell[E, Mana]
struct IceSpike extends Spike[Ice, Freezing, #ice_spike]
struct NeedleIceSpike extends Spike[Ice, Penetrating, #needle_ice_spike]
struct EarthSpike extends Spike[Earth, Penetrating, #earth_spike]

func rawDamage(Spike[Ice, Specialty, #ice_spike]): Damage = 10
func rawDamage(Spike[Ice, Specialty, #needle_ice_spike]): Damage = 12
func rawDamage(Spike[Earth, Specialty, Any]): Damage = 8

// We would usually define this for any Specialty and then override only Penetrating, but the point here is testing
// that the totality constraint sees that all possibilities have been covered.
func damageOf(spell: Spike[Ice | Earth, Freezing, Any], defense: Defense): Damage = calculateDamage(rawDamage(spell), defense)
func damageOf(spell: Spike[Ice | Earth, Penetrating, Any], defense: Defense): Damage = {
  // `Penetrating` ignores 50% of defense.
  calculateDamage(rawDamage(spell), floor(defense / 2))
}

func calculateDamage(rawDamage: Damage, defense: Defense): Damage = max(rawDamage - defense, 0)


func test(): [Damage] = {
  let iceSpike = IceSpike()
  let needleIceSpike = NeedleIceSpike()
  let earthSpike = EarthSpike()

  [
    damageOf(iceSpike, 0),
    damageOf(needleIceSpike, 0),
    damageOf(earthSpike, 0),
    damageOf(iceSpike, 5),
    damageOf(needleIceSpike, 5),
    damageOf(earthSpike, 5),
    damageOf(iceSpike, 12),
    damageOf(needleIceSpike, 12),
    damageOf(earthSpike, 12)
  ]
}
