use lore.core.to_string
use lore.Enum.map
use lore.String

struct Function[-A, +B](f: A => B)

@where A, B, V <: A
func apply(fun: Function[A, B], v: V): B = fun.f(v)

// TODO (modules): Tricky. If we want type aliases to provide struct bindings, we have to somehow tune binding name
//                 resolution such that a type alias defines a binding, but ONLY if the type that the type alias points
//                 to is a struct.
type StringFunction[A] = Function[A, String]
type IntConsumer[B] = Function[Int, B]
type Int2IntFunction = Function[Int, Int]


func test(): [String] = do
  let f1 = StringFunction((x: Int) => 'hey int $x')
  let f2 = StringFunction((list: [Int]) => list |> map(f1.f) |> String.join(', '))
  let f3 = IntConsumer(x => x * 0.4)
  let f4 = Int2IntFunction(x => x + 2)

  let data = [
    apply(f1, 5), apply(f1, 2),
    apply(f2, []), apply(f2, [1, 2, 3]),
    apply(f3, 5), apply(f3, 2),
    apply(f4, 2), apply(f4, -1),
  ]
  data |> map(to_string)
end
