trait Array[+A]

@where A
func at(Array[A], index: Int): A

@where A, E <: A
act prepend(Array[A], element: E)

@where A, E <: A
act append(Array[A], element: E)

@where A
act remove_first(Array[A])

@where A
act remove_last(Array[A])


struct NaiveArray[A] extends Array[A]
  mut underlying: [A]
end

// TODO: Given these functions, the compiler should not allow `NaiveArray` to extend a covariant `Array[A]`. But can we
//       deduce this? Right now, trying to add a Real to a NaiveArray[Int] via an Array[Real] interface leads to a
//       run-time error. This is acceptable, but might not be good enough.
@where A
func at(array: NaiveArray[A], index: Int): A = get(array.underlying, index)

@where A, E <: A
act prepend(array: NaiveArray[A], element: E) do
  array.underlying = concat([element], array.underlying)
end

@where A, E <: A
act append(array: NaiveArray[A], element: E) do
  array.underlying = array.underlying :+ element
end

@where A
act remove_first(array: NaiveArray[A]) do
  array.underlying = tail(array.underlying)
end

@where A
act remove_last(array: NaiveArray[A]) do
  array.underlying = init(array.underlying)
end


func test(): [Int] = do
  let array = NaiveArray([1, 2])
  append(array, 3)
  append(array, 4)
  append(array, 5)
  prepend(array, 0)
  remove_last(array)
  remove_first(array)
  remove_first(array)
  array.underlying
end
