action hello(value: String | Int)

action hello(name: String) {
  println('Hello, $name.')
}

action hello(id: Int) {
  println('Hello, anonymous #$id.')
}

// TODO: Don't encourage doing this, probably. We'd have to handle narrowing list types to [Nothing] after elements
//       are removed if we want to support this particular feature. This is feasible, but not consistent with the
//       rest of the widen-only policy. Narrowing lists of arbitrary size is simply not fast enough and provides
//       little value. I feel like allowing then dispatch for this one special case [Nothing] would be a noob trap
//       as they'd extrapolate this limited feature to mean that this works for all element types in general.
function isEmpty(list: [A]): Boolean where A = false
function isEmpty(list: [Nothing]): Boolean = true

action test() {
  let mut names: [String | Int] = []
  names = names :+ 'world'
  names = names :+ 5
  names = names :+ 'marco'
  names = names :+ 'console'
  names = names :+ 100
  for (name <- names) {
    hello(name)
  }

  println(isEmpty(names))
  println(isEmpty([]))
}

function testPerformanceInner(times: Int): Real = {
  let now = now() // TODO: This should lead to a "variable not found/initialized" error once we introduce first-class functions.
  let mut i = 0
  while (i < times) {
    test()
    i += 1
  }
  let now2 = now()
  now2 - now
}

action testPerformance(times: Int) {
  // Pre-run for the JIT.
  let time1 = testPerformanceInner(times)
  println('Pre-Running test() $times times took ${time1}ms.')

  // Then run ten times and see how performance evolves.
  let mut i = 0
  while (i < 10) {
    let time = testPerformanceInner(times)
    println('Running test() $times times took ${time}ms.')
    i += 1
  }
}
