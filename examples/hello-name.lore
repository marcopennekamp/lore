action hello(value: String | Int)

action hello(name: String) {
  println('Hello, $name.')
}

action hello(id: Int) {
  println('Hello, anonymous #$id.')
}

action test() {
  // TODO: Big problem. Empty lists are typed as [Nothing], so they don't get typed correctly, because run-time types
  //       stay constant after construction...
  // TODO: Second problem: Because the current implementation of lists is mutable, we cannot actually have the subtyping
  //       rules for lists that we have. Mutable lists must be invariant! So either make lists immutable or remove the
  //       subtyping rule. (I'd prefer the first option right now.)
  // TODO: This doesn't work either: `let names: [String | Int] = [10]`. That's because the list is missing the sum
  //       type during construction...
  let names: [String | Int] = []
  names = append(names, 'console')
  names = append(names, 100)
  for (name <- names) {
    hello(name)
  }
}

function testPerformanceInner(times: Int): Real = {
  const now = now() // TODO: This should lead to a "variable not found/initialized" error once we introduce first-class functions.
  let i = 0
  while (i < times) {
    test()
    i += 1
  }
  const now2 = now()
  now2 - now
}

action testPerformance(times: Int) {
  // Pre-run for the JIT.
  const time1 = testPerformanceInner(times)
  println('Pre-Running test() $times times took ${time1}ms.')

  // Then run ten times and see how performance evolves.
  let i = 0
  while (i < 10) {
    const time = testPerformanceInner(times)
    println('Running test() $times times took ${time}ms.')
    i += 1
  }
}
