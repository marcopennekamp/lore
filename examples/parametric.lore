


function identity[A](a: A): A = a
function identity[A <: String](a: A): A = a



function combine[A <: C](v1: A, v2: A): A = ...




// The way we are currently checking subtypes seems to only be sufficient for multiple dispatch,
// but not for checking types in function bodies. Consider:
function foo(a: A): [A] where A = {
  const x: A = 'x'
  const y: A = 1.5
  [x, y]
}

// Right now, we just check that the bounds of A (in this case Any) conform to the actual type.
// So we'd check String <: Any and Real <: Any. Obviously that's wrong. Actually, we don't even
// need two assignments. Just assigning String to an A variable is wrong already. What if
// A is Real?
// Observation: Assigning String to A would be legal if A was GUARANTEED to be a SUPERTYPE of String.
// Maybe we have to flip the subtyping relationship here to consider a sort of lower bound?

// Let's see another example:
function callme(a: A): A where A <: String = ...

function callit(a: A): A where A = {
  callme('xy')
}

// Again, we have the problem that callme will return a String (as A = String), but callit simply checks whether
// the return type fits the upper bounds of A, in this case Any. So callme('xy') is a valid returning expression,
// even though callit's A might be instanced as something else, such as Real.

// This means we have to introduce a concept of a type's lower bound, which is checked during type-checking of
// "outputting" constructs such as assignments and returns. The lower bound of a type variable would, for now,
// be Nothing, while any other type would calculate its lower bound based on its components or simply have none.
// In this sense, the lower bound can be viewed as saying "this type variable is at most this specific".

// This leaves us with a weird "if this type term has a type variable, do one thing, otherwise do the other"
// when it comes to checking return expressions and assignments. This feels weird, to be honest. Thinking more
// on this, it's not about "outputting" positions at all. Consider the following object instantiation:

function bar(a: A): C[A] where A = {
  C[A]('test')
}

// Since String <: Any, using the current subtyping rules, this would be a valid expression. But we have the same
// issue here: A must be guaranteed to be at most String (i.e. a supertype of String) to make String assignable
// here, but surely an argument is not an "outputting" position.

// Maybe we have to consider a notion "assignability" when we deal with type variables. A value of any type X
// can be assigned to a variable of type A if A's lower bound B ensures X <: B. Because then X can be safely
// assigned to A, as A is at most as specific as B and must be a supertype of B.


function foo[A, B](x: A | B, y: B): () = ...

foo(5, 'a')
(Int, String) <: (A | B, B)
   A = Int AND B = Int
OR A = Int AND B = String

foo('test', 'b')
(String, String) <: (A | B, B)
   A = String AND B = String

// Insight: Sum type substitutions lead to a sort of branching.


function bar[A, B](x: A & B, y: B): [B] = [x, y]

// Assume entities E1 & +C1 and E2 & +C1.
bar(E1(), E2())
(E1, E2) <: (A & B, B)
      A = E1 & +C1
   OR B = E1 & +C1
   ???
=>    A = E1 AND B = +C1
   OR A = +C1 AND B = E1
   ???

// Insight: Complexity quickly explodes. Maybe don't support sum and intersection types with type variables
//          from the start?


function append[A](as: [A], a: A): [A] = ...

// Assume cs: [+C1], e: E1 & +C1
append(cs, e)
([+C1], E1 & +C1) <: ([A], A)
   A = +C1 AND A = E1 & +C1
=> A = +C1

// Insight: We must require type variables to be instanced over equality modulo intersection type equivalences.
//          Meaning: If we substitute multiple types A & B, A, A & C into a type variable, if we can take an
//          unambiguous type T for which T & S for any S holds for all substitutions (A in the given example),
//          that T is valid. That's easy to see: If we have a value of type A & B, it MUST be able to be treated
//          EXACTLY like a value of type A or B, down to parametric polymorphism.


append(['A'], 'B')
([String], String) <: ([A], A) ?

Substitutions:
- A => String
- A => String
Consistent!

Subtyping:
- [String] <: [Any]
- String <: Any
Fits!


foo[X](x: X, y: Any): Real = 1
foo[Y <: Real](x: Real, y: Y): Real = 2

(Real, Y <: Real) <: (X, Any) ?

Substitutions:
- X => Real
Consistent!

Subtyping:
- Real <: Any
- Real <: Any
Fits!


1. tail[X](x: [X]) : [X] = ...
2. tail[X <: Real](x: [X]): [X] = ...
3. tail(x: [Int]): [Int] = ...

(1) and (2)
([X1 <: Real]) <: ([X2]) ?
- Substitutions: Consistent!
  - X2 => X1
- Subtyping: Fits!
  - Real <: Any

(2) and (3)
([Int]) <: ([X <: Real]) ?
- Substitutions: Consistent!
  - X => Int
- Subtyping: Fits!
  - Int <: Real

(1) and (3)
([Int]) <: ([X]) ?
- Substitutions: Consistent!
  - X => Int
- Subtyping: Fits!
  - Int <: Any


minimumJX <: R, Y <: ZK p: PairJX, Y K : R
`
 ́
minimumJX <: Z, Y <: RK p: PairJX, Y K : R
minimumJX <: Z, Y <: ZK p: PairJX, Y K : Z


foo[A](collection: C[A], element: A): C[A]
foo(C([5]), 'Haha')

(C[Int], String) <: (C[A], A)
- Substitutions: Inconsistent! Not a subtype.
  - A => Int
  - A => String
- Subtyping:
  - C[Int] <: C[Any]   FALSE (C is not covariant), but SHOULD be true. So we need to take that into account...
                       Idea: Check instance equality instead of subtyping.
  - String <: Any


foo[A, B <: A](collection: C[A], element: B): C[A] = ...
foo(C([Real]), 5)

(C[Real], Int) <: (C[A], B <: A)
- Substitutions: Consistent!
  - A => Real
  - B => Int
  - Check variable relationships:
    - B <: A means Int <: Real
- Subtyping: Fits!
  - C[Real] <: C[A]
    - Real =%= A ==> Real <: Any
  - Int <: A ==> Int <: Any  <--- This might actually become a problem. My intuition tells me that we need to compare
                                  against the instanced value of A, Real, here. Can we find an example where this
                                  naive check actually fails?

class T1
class T2

foo(C([T1()]), T2())

(C[T1], T2) <: (C[A], B <: A) ?
- Substitutions: Inconsistent!
  - A => T1
  - B => T2
  - Check variable relationships:
    - B <: A means T2 <: T1 <--- false!


// Specificity edge case: ?

foo(a: X, b: Y) where X, Y     // 1
foo(a: A, b: A) where A        // 2
foo(a: String, b: A) where A   // 3

// This SHOULD thus have the following specificity:
//    foo2 <* foo1, foo3 <* foo1, foo3 </* foo2, foo1 </* foo2, foo1 </* foo3
