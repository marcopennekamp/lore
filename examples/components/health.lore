// This example shows how to define a very basic entity-component situation as known from game development.
// Even with this simple example, you can see how Lore lends itself well to modular programming. We can define
// functions over subsets of components of Skeleton, while we still have access to all other components we need.
// And everything without dynamically getting components like you do in Unity.

class Position {
  // Only 'mut' fields are mutable.
  mut x: Float
  mut y: Float
  mut z: Float
}

// We can restrict the types that Sprite can be owned by. However, this will only apply when Sprite is used as a
// component. Sprite can still be created and passed to any function that expects a Sprite, no matter whether it's
// a component or not. A component can also be part of multiple entities; there are no basic restrictions to this,
// as explained in the specification.
class Sprite owned by +Position {
  mut image: Image
}

class Entity2D {
  component Position
  component Sprite
}

// Once envelope types are available, we can use the envelope to represent the health state (simply calling it Health).
// This might not be wise in one case: If we later want to add more values to the health state, we'd have to change
// all instances where the Health envelope was used. The programmer should weigh these concerns and choose the
// appropriate type to represent the component.
class HealthState {
  mut health: Int
}

action heal(entity: +HealthState, amount: Int) { entity.HealthState.health += amount }
action damage(entity: +HealthState, amount: Int) { entity.HealthState.health -= amount }

// Idea for later: Even mutable fields are immutable by default, unless a variable is declared as mutable. So declaring
// the first parameter as mut will allow mutable fields to be mutated. For now, this feature is too complex to implement
// for the first iteration of the language. But when Lore becomes more advanced, this will be a good feature to
// segregate functions that mutate a value (maybe we can rather declare the FUNCTION as mutating) and functions that
// only calculate something.
// action heal(mut entity: +HealthState, amount: Int) { entity.HealthState.health += amount }

// Idea for later: Object destructuring right in the parameter declaration.
// action heal({ HealthState }: +HealthState, amount: Int) { HealthState.health += amount }

class Regeneration owned by +HealthState {
  amount: Float
  interval: Int
  private mut counter: Int = 1 // private hides the field from any function defined outside the current file.
}

// We could try to define the function as
//   action updateHealth(mut r: Regeneration)
// but then we can't access the owner, since we don't know if Regeneration has been attached to an entity yet!
// Instead, we define it as follows, which makes sure that Regeneration is attached to an entity. Since we require
// Regeneration to be attached to entities that also have a HealthState, we can access the health state without
// declaring it explicitly.
action updateHealth(entity: +Regeneration) {
  const r = entity.Regeneration
  if (remainder(r.counter, r.interval) == 0) {
    heal(entity, amount)
  }
  r.counter += 1
}

// With all the declared components, the expanded type of Skeleton is something like:
//   Skeleton & +Position & +Sprite & +HealthState & +Regeneration
// Note that Skeleton inherits the components of Entity2D.

class Skeleton extends Entity2D {
  component HealthState
  component Regeneration
  // Idea for later: Declare default component values:
  // component Regeneration = Regeneration(amount = 5, interval = 30)
}

action tick(s: Skeleton) = {
  updateHealth(s)
}
