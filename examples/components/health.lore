// This example shows how to define a very basic entity-component situation as known from game development.
// Even with this simple example, you can see how Lore lends itself well to modular programming. We can define
// functions over subsets of components of Skeleton, while we still have access to all other components we need.
// And everything without dynamically getting components like you do in Unity.

class Position {
  // Only 'mut' fields are able to be mutated.
  mut x: Float
  mut y: Float
  mut z: Float
}

// We can restrict the types that Sprite can be owned by. However, this will only apply when Sprite is used as a
// component. Sprite can still be created and passed to any function that expects a Sprite, no matter whether it's
// a component or not. A component can also be part of multiple entities; there are no basic restrictions to this
// at this time. We might restrict it later, but that will require advanced language features, and I want to
// concentrate on core features first.
class Sprite owned by +Position {
  mut image: Image
}

class Entity2D {
  component Position
  component Sprite
}

// TODO: Shouldn't this be called just Health? Can we use an envelope type for this? Think about how envelope types
//       could be used as components in general. Is this wise considering extendability?
class HealthState {
  mut health: Int
}

function heal(entity: +HealthState, amount: Int): Unit = { entity.HealthState.health += amount }
function damage(entity: +HealthState, amount: Int): Unit = { entity.HealthState.health -= amount }

// Idea for later: Declaring the first parameter as mut will allow mutable fields to be mutated. For now,
// this feature is too complex to implement for the first iteration of the language. But when Lore becomes
// more advanced, this will be a good feature to segregate functions that mutate a value and functions that
// only calculate something.
// function heal(mut entity: +HealthState, amount: Int): Unit = { entity.HealthState.health += amount }

// Idea for later: Object destructuring right in the function arguments.
// function heal({ HealthState }: +HealthState, amount: Int): Unit = { HealthState.health += amount }

// Idea for later: Declare functions that return unit and mutate state as actions.
// action heal(entity: +HealthState, amount: Int) { entity.HealthState.health += amount }

class Regeneration owned by +HealthState {
  amount: Float
  interval: Int
  private mut counter: Int = 1 // private hides the field from any function defined outside the current file.
}

// We could try to define the function as
//   function tick(mut r: Regeneration): Unit
// but then we can't access the owner, since we don't know if Regeneration has been attached to an entity yet!
// Instead, we define it as follows, which makes sure that Regeneration is attached to an entity. Since we require
// Regeneration to be attached to entities that also have a HealthState, we can access the health state without
// declaring it explicitly.
function updateHealth(entity: +Regeneration): Unit = {
  const r = entity.Regeneration
  if r.counter `mod` r.interval == 0 {
    // Idea for later: Any function that takes a value as its first argument can be called by using the dot notation.
    // entity.heal(amount)
    heal(entity, amount)
  }
  r.counter += 1
}

// With all the declared components, the expanded type of Skeleton is something like:
//   Skeleton & +Position & +Sprite & +HealthState & +Regeneration
// Note that Skeleton inherits the components of Entity2D.

class Skeleton extends Entity2D {
  component HealthState
  component Regeneration = Regeneration(amount = 5, interval = 30) // We can declare default component values.
}

function tick(s: Skeleton): Unit = updateHealth(s)
