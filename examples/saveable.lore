/**
 * This example shows how we can implement implicit interfaces in Lore.
 * Imagine a situation in which we want to save an object. We have a code generator that generates the implementation
 * of an action 'save' for any struct extending Saveable as long as all its attributes are Saveable as well. One of the
 * attributes is an object 'obj' of a struct 'Obj' defined outside our own code, in a library which we do not want to
 * modify. Unfortunately, said object does not implement the Saveable interface. With implicit interfaces, we can
 * implement the interface without modifying the original code. Our code generator can do the following:
 *   1. For each attribute a of A that is to be saved, check if A <: Saveable.
 *   2. If A is Saveable, simply call save(a).
 *   3. Otherwise, we specialise the type of 'a' at run-time, by calling save(a & Saveable). This will narrow the type
 *      of 'a' to A & Saveable, but also introduce a new check: The specialisation is only valid if A & Saveable
 *      implements 'save'.
 * Also compare to dynamic-interfaces.lore.
 */

trait Saveable
action save(object: Saveable)
action save(value: Real) { /* save the real... */ }

// A standard 2D position that can be saved.
struct Position implements Saveable { x: Real, y: Real }

// The following action will be generated by the Saveable code generator. This is not an existing feature of Lore,
// of course, just an example.
action save(pos: Position) {
  /* save the position... */
  save(pos.x)
  save(pos.y)
}

// TODO: We would ordinarily specialize ExternalPhysics at run-time in Character's save function. To make this
//       example compile in the current circumstances, the trait extends Saveable. This would not be possible
//       if ExternalPhysics was declared in an external library, so be wary of this "hack".
trait ExternalPhysics extends Saveable

struct Character implements Saveable {
  component Position
  // TODO: Aaand we have our first (unexpected), real-world example of the supertype of two components clashing.
  //       This is an absolutely legitimate example, which is only not possible because the language is too constrained.
  //       Saveable should be defined as a sort of "can't be a component" type (see the spec). Until then, this example
  //       will have to be defined with a property physics: ExternalPhysics instead of an ExternalPhysics component.
  // component ExternalPhysics
  physics: ExternalPhysics
}

action save(char: Character) {
  /* save the character... */
  save(char.Position)
  save(char.physics)
}

// Assuming that ExternalPhysics isn't Saveable, we define the following action.
action save(object: ExternalPhysics & Saveable) {
  // Save the physics object.
}

// Now, the code generator should be able to call save(character.ExternalPhysics) and thus generate the save
// function for Character, too.
