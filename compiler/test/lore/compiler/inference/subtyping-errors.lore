trait A
struct B extends A {
  mut name: String
}

// Illegal: `shape.prop` has the type A, not B.
func test(): Unit = do
  let shape: %{ prop: A } = %{ prop: B('') }
  let result: B = shape.prop
end

func pi(): Real = 3.14

// Illegal: 5.5 is a Real, not an Int.
act test2()
  let number: Int = 5.5
end

// Illegal: `test()` evaluates to Unit, not a Real.
func test3(): Real = do
  15 + test()
end

// TODO: This error is reported as "This expression has the illegal type String. We expected the following type (or a
//       supertype thereof): Real." The error is reported the wrong way, as we expect Real to be a subtype of String.
//       The problem is that both sides of the Subtypes judgment `iv59 :<: iv57` are inference variables. The reporting
//       algorithm currently makes the inference variable for which `narrowBounds` failed the point of error. In this
//       case, iv59 and iv57 will both experience bounds narrowing errors. iv59 is just narrowed first.
//       The universal solution is likely adding custom errors to typing judgments in general. This should allow us to
//       further improve error reporting.
// Illegal: `b.name` must be a String.
/* func test4(): A = do
  let b = B('')
  b.name = pi()
  b
end */

func increment(number: Int): Real = number + 1.5

func test5(): %{ number: Int } = do
  // Illegal: `increment` returns a Real, but Int is expected.
  let abc: %{ number: Int } = %{ number: increment(2) }
  abc
end
