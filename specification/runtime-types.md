# Run-time Types

This document describes Lore's **run-time type semantics**, which are crucial for run-time multiple dispatch. Due to reasons of practicality and performance, Lore cannot guarantee that the run-time type of some specific value kinds is composed of actual run-time value types.

In general, we have the following rule: *A value's type must be immutable once the value has been constructed. It must not change during subsequent mutations of the value.*

Here are the **rules** for each kind of value:

- **Integers, reals, booleans, strings, and symbols** are trivial, as they simply carry their type.
- **Tuple** types are created from their actual run-time element types during tuple construction.
- **Function** values receive their *compile-time type*.
- **List** values receive their *compile-time type*.
  - Many list operations take away a part of the list. If we guaranteed that list values always had their narrowest possible type, we would have to recompute the element type from all actual element values every time that a list is split, the `tail` or `init` is taken, or simply an arbitrary element is removed. It's a *performance decision* to type run-time lists with their compile-time types.
  - For example, the operation `['hello', 1, 2] |> List.tail` still types the list as `[String | Int]`. It might be obviously strange in this simple case, but the search for a general solution will quickly get out of hand.
  - The append operation for lists also creates a new list with the append result's compile-time type.
  - The run-time type semantics for lists are conservative. If we find a data structure that gracefully handles element type changes based on value additions and removals, without it overly affecting performance, guaranteeing the narrowest possible element type would not break much if any existing code. The only code to be broken would rely on spurious type semantics.
- **Maps** are currently under review and will be overhauled at a later date.
- **Shape** types are created from their actual run-time element types during shape construction.
- **Struct** values receive their *compile-time type* at construction, including the struct's type arguments. The exception are open type parameters and open property types, which are decided from actual run-time property values.
  - As open properties may not be mutable, the type immutability rule above holds.
  - Struct/shape subtyping is usually decided based on the struct's compile-time property types, except for open properties.

Whenever a value receives its **compile-time type**, the type is added as a constant to the generated bytecode. Any type variables contained in the type constant will be substituted with the type arguments of the function in which the value is constructed. So if a list is typed as `[A]` at compile time, with `A` being a type variable, its run-time type might become `[Real]` given `A = Real`.
