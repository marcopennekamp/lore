# Functional Constructors

For each class, exactly one constructor is defined and generated by the compiler, which will just be a function that constructs the desired value. You can define additional functions that construct a value, but they will have to use the (generated) constructor. Getting rid of the special status of constructors, which is present in so many object oriented languages, allows us to improve the flexibility of constructors by treating them as ordinary functions.


### Constructors

TODO: Require class constructors to be declared manually. Still allow unique supertype values to be used as "super". 
      Introduce structs, which are classes with public-only members whose constructor is generated by the compiler.

Each class `X` defines a *constructor* `X :: (T1, ..., Tn) -> X` for some types `T1` through `Tn`. You **must** use this constructor to create instances of `X`.

It is generated as follows: Attributes and components are added to the constructor's parameter list in the order that they appear in inside the type's body. Each attribute parameter adopts the appropriate type of the attribute. A component of type `C` will result in a parameter type `@C`, because component objects need to be bound to the owner object. Default attribute values are added as default argument values to the root constructor.

If the class `X` extends some other class `S`, we need to construct a value of `S` first. In addition, we don't want to force the programmer to use the constructor of `S`,  we want to allow building `X` on top of any untouched value of `S`. This adds a parameter to the type of the generated constructor: `X: @S -> (T1, ..., Tn) -> X`. The bindable will make sure that the value has not been used in any other way, so that it can be used as a base for the new `X` value. What it exactly means to *extend* or *morph* a value of `S` to a value of `X` is left to the implementation.

For example, take the following class:

    class Skeleton extends Entity2D {
        component HealthState
        private const boneCount :: Int = 5
        ...
    }

The root constructor of `Skeleton` has the following signature:

    Skeleton (super :: @Entity2D) (HealthState :: @HealthState, boneCount :: Int = 5)

Note that the first parameter expects a bindable `Entity2D`, which is the superclass of `Skeleton`. The default attribute value for `boneCount` ends up as a default argument value.


### User-defined Constructors

User-defined constructors can be expressed as ordinary functions that use the (generated) constructor of a class. For example, we can define a constructor function `FromFahrenheit` that creates a `Kelvin` value:

    function FromFahrenheit v :: Float -> Kelvin = Kelvin((v + 459.67) * (5/9))

It is also perfectly feasible to write a function that returns a constructor function:

    function TemperatureFactoryFactory c :: Country -> (Float -> Temperature) = ...

Most of these functions should be declared in the companion object of the class, so that they'd be called like this:

    Kelvin.FromFahrenheit 77.45


### Overwriting Generated Constructors

It is sometimes inconvenient to expose private attributes through the root constructor, especially when it comes to attributes like `boneCount` in the example above. In such and other cases, you can overwrite the root constructor as follows:

    class Clock {
        component Position
        private mut time :: Float = 0.0
    }

    object Clock {
        function Clock (position :: @Position) = this position // Note that the time parameter receives its default value.
    }

TODO: Can we find a better syntax than `this ...` for this?

TODO: We also need to rethink the `function Clock (Position :: @Position)` syntax. It's special, yet still looks like a normal function.

TODO: Alternative 1: Annotate attributes with default values to be excluded from the generated constructor.
      Alternative 2: Allow making the generated constructor private, then expose user-defined constructors.
