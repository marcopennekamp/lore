\chapter{Interfaces}

In this chapter, we will lay out how interfaces can be integrated into a language with multiple dispatch. We will see that we already have all features we need to define classic interfaces. To get there, we will first consider the problem of expanding classic, single dispatch interfaces from object-oriented languages to interfaces in a multiple dispatch language. We will propose a functionally equivalent style for defining interfaces that makes use of already described features. Finally, we will consider the notion of implicit interfaces and how they fit into our framework.



\section{The Problem with Multiple Dispatch Interfaces}

When defining a classic interface, it is clear which value is dispatched on: The object implementing said interface provides the implementation of the interface. Let's consider the classic example of entities colliding in a game. In a single dispatch world, we would have the following interface:

\begin{lstlisting}
interface Collidable {
    void collideWith(other: Collidable): Option[Collision]
}
\end{lstlisting}

\noindent How do we go about expanding this to a multiple dispatch interface? The collide function outside an interface would be declared as follows:

\begin{lstlisting}
function collide(c1: Collidable, c2: Collidable): Option[Collision]
\end{lstlisting}

\noindent The problem that emerges is that we can't say "c1 has an associated function collide", because while the interface reasons about \textit{function shapes}, the type of a parameter reasons about \textit{value shapes}. As soon as we have two parameters in a multiple dispatch world, the notion of an interface as a type breaks down, because the type of the first parameter would have to reason about the type of the second parameter, while the second parameter may propose conflicting notions about the first parameter. 

Luckily, it turns out that this problem can be solved quite easily by throwing out the notion of an interface and replacing it with the power of abstract functions, label types and subtyping, as we will see in the next section.



\section{Multiple Dispatch Interfaces}

An interface in Lore is a \textit{label type} associated with one or more \textit{abstract functions}. For example, the \type{Collidable} interface mentioned above could be defined as follows:

\begin{lstlisting}
label type Collidable
function collide(c1: Collidable, c2: Collidable): Option[Collision]
\end{lstlisting}

\noindent \textit{Implementing} the interface for a type \type{A} would amount to making \type{A} a subtype of the label type, i.e. \type{A <: Collidable}. For a hypothetical asteroid, we would have the following type declaration:

\begin{lstlisting}
class Asteroid <: Collidable { ... }
\end{lstlisting}

\noindent Due to the totality constraint on abstract functions (see definition \ref{def:totality-constraint}), since \type{Asteroid} is a direct subtype of \type{Collidable}, we need to implement the function \texttt{collide} for \type{Asteroid}. We could defer to an abstract function in this case, provided the second parameter type is abstract, which would make the argument tuple type abstract.\footnote{If the second parameter type is also instantiable, the input abstractness constraint (see definition \ref{def:input-abstractness-constraint}) would be violated if we try to declare an abstract function on non-abstract parameter types.}


\subsection{Implementing Multiple Interfaces}


\subsection{Fighting the Global Namespace}



\section{Implicit Interfaces}

So far, we have only considered interfaces that are implemented via nominal typing. We can also consider structurally typed interfaces, which we will call \textit{implicit interfaces}. Consider a value \texttt{a} of type \type{A} and an implicit interface \type{I}. Suppose \type{A <: I} is \textit{not} true, but \type{A} implements all functions correctly such that it could be a subtype of the interface without any additional modifications. Since \type{I} is an implicit interface, we want to be able to pass around \texttt{a} as if it had the type \type{I}.

Our proposed solution makes use of intersection types and run-time type specialisation. First, consider the following interface:

\begin{lstlisting}
label type Saveable
function save(object: Saveable): Unit
\end{lstlisting}

\noindent Imagine a situation where we want to save an object. We have a code generator that generates the implementation of \texttt{save} for a \type{Saveable} class as long as all its attributes are \type{Saveable} as well. One of the attributes is an object \texttt{obj} of a class \texttt{Obj} defined outside our own code, in a library which we do not want to modify. Unfortunately, said object does not implement the \type{Saveable} interface. With implicit interfaces, we can implement the interface without modifying the original code. Our code generator can do the following:

\begin{enumerate}
	\item For each attribute \texttt{a} of \type{A} that is to be saved, check if \texttt{A <: Saveable}.
	\item If \type{A} is \type{Saveable}, simply call \texttt{save(a)}.
	\item Otherwise, we specialise the type of \texttt{a} at \textit{run-time}, by calling \texttt{save(a \& Saveable)}. This will narrow the type of \texttt{a} to \type{A \& Saveable}, but also introduce a new check: The specialisation is only valid if \type{A \& Saveable} implements \texttt{save}.
\end{enumerate}

\noindent Note that we need to implement \texttt{save} for \type{Obj \& Saveable} specifically, \textbf{not} for \type{Obj}, since \type{Obj <: Saveable} is still not true, but \type{Obj \& Saveable <: Saveable} is, trivially so. Since the interface function expects a \type{Saveable} value, our function parameter needs to subtype it if we want the dispatch to work correctly.

This delegates the burden of implementation from the implementation of an interface to the correct implementation of the \texttt{save} function only. We can finally manually implement the function as follows, in any location we choose:

\begin{lstlisting}
function save(object: Obj & Saveable): Unit = ...
\end{lstlisting}




