\chapter{Multi-Functions}

Functions of the same name belong to an accordingly named set of functions. Such a function set is called a \textit{multi-function}. A function that belongs to a multi-function is also called an \textit{instance} of that multi-function. Multi-functions can be called like ordinary functions. The actual function being called is chosen at runtime as the function that is most general in the set of functions fulfilling the subtyping relation comparing the actual (dynamic) argument types with each function's parameter types. We call this kind of invocation \textit{multiple dispatch}. 

Multi-Functions are useful, because they allow functions to be implemented with varying levels of generality. They lend themselves well to a varying ensemble of features and concerns:
\begin{itemize}
	\item \textbf{Ad-hoc Polymorphism} is supported natively, since multiple dispatch is a superset of single dispatch, which is used to implement ad-hoc polymorphism in object-oriented languages.
	\item \textbf{Intersection Types} composed of component, interface or semantic types can be used to define a sufficiently specific type for a given operation. Furthermore, varying degrees of increasingly specific intersection types can be used to specialise a function in different ways. This sufficiently specific type can be used to implement a function which would otherwise have been confined to a class hierarchy in object-oriented programming, thus sacrificing flexibility.
	\item \textbf{Dynamic specialisation and generalisation} of values can be used to specialise or generalise\footnote{Of course supposing that the generalised type still satisfies the type boundaries that its value is subject to.} the type of a value at \textit{runtime}. Since the actual function being called is chosen at runtime when calling a multi-function, we can write functions that implement an operation for a given specialised type.
	\item \textbf{Extendability} is improved by the ability to define multi-functions \textit{across} files and compilation units. This supports features such as C$^\sharp$'s extension methods or Scala's implicit classes in a more concise way.
\end{itemize}

\noindent In this chapter, we will look at the the syntax of function declarations and define functions and multi-functions. After laying out the basics, we will define the rules of multiple dispatch and examine edge cases. We will see how ad-hoc polymorphism, intersection types and dynamic specialisation/generalisation can be used as proposed above.



\section{Functions and Multi-Functions}

\begin{grammar}
\nt{func-def} &\produce \rh{\nt{func-head} = \nt{expr}} \\
\nt{func-head} &\produce \rh{\tn{function} \nt{id}\lpar\nt{func-params}\rpar [\tn{:} \nt{type}]\once} \\
\nt{func-params} &\produce \rh{\nt{func-param} [\tn{,} \nt{func-param}]\onceplus} \\
&\alt \rh{\nt{func-param}\once} \\
\nt{func-param} &\produce \rh{\nt{id} [\tn{:} \nt{type}]\once}
\end{grammar}

\noindent A \textbf{function} $f$ is a mapping from an input type $\funcin(f)$ to an output type $\funcout(f)$. Each function has a name, which we denote $\funcname(f)$. Note that the $\nt{id}$ of a function is not necessarily equal to its full name.\todo{Read more here...} The $\funcbody(f)$ of a function is an expression $e = \funcbody(f)$. The type of $e$ must be a subtype of $\funcout(f)$.

The input type of a function $f$ is defined as follows: Let $[\tau_1, ..., \tau_n]$ be the list of parameter types for each parameter $p_i \in \{ 1, ..., n \}$. Then we have $\funcin(f) = (\tau_1, ..., \tau_n)$, i.e. an n-tuple over the list of parameter types.

We denote the set of all possible functions as $\funcset$.

\begin{example}
	Consider the following definition for a function add:
	\begin{lstlisting}
function add(a: Int, b: Int): Int = a + b
	\end{lstlisting}
	
	\noindent We will call the defined function $f$. We have the following properties:
	\begin{align*}
		\funcname(f) &= \idval{add} \\
		\funcin(f) &= \type{(Int, Int)} \\
		\funcout(f) &= \type{Int} \\
		\funcbody(f) &= \expr{a + b}
	\end{align*}
\end{example}

\noindent A \textbf{multi-function} is a 2-tuple $\mathcal{F} = (n, F)$ where:
\begin{itemize}
	\item $n$ is the name of the multi-function.
	\item $F$ is the set of functions belonging to the multi-function.
\end{itemize}

\noindent We define $F$ as follows:
\begin{equation*}
	F = \{ f \in \funcset \mid \funcname(f) = n \}
\end{equation*}

\noindent That is, a multi-function is a set of functions that share the same name. By convention, we sometimes write $f \in \mathcal{F}$ for $f \in F$. A function $f \in \mathcal{F}$ is also called an \textbf{instance} of $\mathcal{F}$. We denote the set of multi-functions as $\mfset$.

\begin{example}
	Consider the following function definitions:
	\begin{lstlisting}
function concat(a: ToString, b: ToString) = ...
function concat(a: List[a], b: List[a]) = ...
function concat(a: LinkedList[a], b: LinkedList[a]) = ...
	\end{lstlisting}
	
	\noindent Assuming no other function with the name \idval{concat} exists, we have the multi-function $\mathcal{F}_\idval{concat} = (\idval{concat}, F)$, where $F$ is the set of \idval{concat} functions defined above.
\end{example}



\section{Multiple Dispatch}

To define multiple dispatch formally, we first need an operation that allows us to reduce the set of multi-function instances to only those functions that fit a given type bound.

We define a function $\mffit : \typeset \rightarrow \mfset \rightarrow \powerset{\funcset}$ as follows:
\begin{equation*}
	\mffit(b)((\wildcard, F)) = \{ f \in F \mid \funcin(f) \leq b \}
\end{equation*}

\noindent That is, we look at all functions $f \in F$ and choose only those whose input type is a subtype of the given type bound $b$.




\todo{Intersections with semantic types can be used to define a state, as used in Papyrus script (https://www.creationkit.com/index.php?title=States_(Papyrus)).}

