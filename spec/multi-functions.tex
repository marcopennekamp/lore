\chapter{Multi-Functions}

Functions of the same name belong to an accordingly named set of functions. Such a function set is called a \textit{multi-function}. A function that belongs to a multi-function is also called an \textit{instance} of that multi-function. Multi-functions can be called like ordinary functions. The actual function being called is chosen at runtime as the function that is most specific in the set of functions fulfilling the subtyping relation comparing the actual (dynamic) argument types with each function's parameter types. We call this kind of invocation \textit{multiple dispatch}. 

Multi-Functions are useful, because they allow functions to be implemented with varying levels of generality. They lend themselves well to a varying ensemble of features and concerns:
\begin{itemize}
	\item \textbf{Ad-hoc Polymorphism} is supported natively, since multiple dispatch is a superset of single dispatch, which is used to implement ad-hoc polymorphism in object-oriented languages.
	\item \textbf{Intersection Types} composed of component, interface or semantic types can be used to define a sufficiently specific type for a given operation. Furthermore, varying degrees of increasingly specific intersection types can be used to specialise a function in different ways. This sufficiently specific type can be used to implement a function which would otherwise have been confined to a class hierarchy in object-oriented programming, thus sacrificing flexibility.
	\item \textbf{Dynamic specialisation and generalisation} of values can be used to specialise or generalise\footnote{Of course supposing that the generalised type still satisfies the type boundaries that its value is subject to.} the type of a value at \textit{runtime}. Since the actual function being called is chosen at runtime when calling a multi-function, we can write functions that implement an operation for a given specialised type.
	\item \textbf{Extendability} is improved by the ability to define multi-functions \textit{across} files and compilation units. This supports features such as C$^\sharp$'s extension methods or Scala's implicit classes in a more concise way.
\end{itemize}

\noindent In this chapter, we will look at the the syntax of function declarations and define functions and multi-functions. After laying out the basics, we will define the rules of multiple dispatch and examine edge cases. We will see how ad-hoc polymorphism, intersection types and dynamic specialisation/generalisation can be used as proposed above.



\section{Functions and Multi-Functions}

\begin{grammar}
\nt{func-def} &\produce \rh{\nt{func-head} = \nt{expr}} \\
\nt{func-head} &\produce \rh{\tn{function} \nt{id}\lpar\nt{func-params}\rpar [\tn{:} \nt{type}]\once} \\
\nt{func-params} &\produce \rh{\nt{func-param} [\tn{,} \nt{func-param}]\onceplus} \\
&\alt \rh{\nt{func-param}\once} \\
\nt{func-param} &\produce \rh{\nt{id} [\tn{:} \nt{type}]\once}
\end{grammar}

\noindent A \textbf{function} $f$ is a mapping from an input type $\funcin(f)$ to an output type $\funcout(f)$. Each function has a name, which we denote $\funcname(f)$. Note that the $\nt{id}$ of a function is not necessarily equal to its full name.\todo{Read more here...} The $\funcbody(f)$ of a function is an expression $e = \funcbody(f)$. The type of $e$ must be a subtype of $\funcout(f)$.

The input type of a function $f$ is defined as follows: Let $[\tau_1, ..., \tau_n]$ be the list of parameter types for each parameter $p_i \in \{ 1, ..., n \}$. Then we have $\funcin(f) = (\tau_1, ..., \tau_n)$, i.e. an n-tuple over the list of parameter types.

We denote the set of all possible functions as $\funcset$.

\begin{example}
	Consider the following definition for a function add:
	\begin{lstlisting}
function add(a: Int, b: Int): Int = a + b
	\end{lstlisting}
	
	\noindent We will call the defined function $f$. We have the following properties:
	\begin{align*}
		\funcname(f) &= \idval{add} \\
		\funcin(f) &= \type{(Int, Int)} \\
		\funcout(f) &= \type{Int} \\
		\funcbody(f) &= \expr{a + b}
	\end{align*}
\end{example}

\noindent A \textbf{multi-function} is a 2-tuple $\mathcal{F} = (n, F)$ where:
\begin{itemize}
	\item $n$ is the name of the multi-function.
	\item $F$ is the set of functions belonging to the multi-function.
\end{itemize}

\noindent We define $F$ as follows:
\begin{equation*}
	F = \{ f \in \funcset \mid \funcname(f) = n \}
\end{equation*}

\noindent That is, a multi-function is a set of functions that share the same name. By convention, we sometimes write $f \in \mathcal{F}$ for $f \in F$. A function $f \in \mathcal{F}$ is also called an \textbf{instance} of $\mathcal{F}$. We denote the set of multi-functions as $\mfset$.

\begin{example}
	Consider the following function definitions:
	\begin{lstlisting}
function concat(a: ToString, b: ToString) = ... // f1
function concat(a: List[a], b: List[a]) = ... // f2
function concat(a: LinkedList[a], b: LinkedList[a]) = ... // f3
	\end{lstlisting}
	
	\noindent Assuming no other function with the name \idval{concat} exists, we have the multi-function $\mathcal{F}_\idval{concat} = (\idval{concat}, F)$, where $F = \{ f_1, f_2, f_3 \}$ is the set of \idval{concat} functions defined above.
\end{example}



\section{Multiple Dispatch}

To define multiple dispatch formally, we first need an operation that allows us to reduce the set of multi-function instances to only those functions that could be called with a given tuple of arguments.

\todo{What about output types?}

\todo{How can we support contravariant parameter types seen in object-oriented programming? Should we allow the declaration of "non-dispatch" parameters that won't be used for multiple dispatch and can thus be contravariant?}

\medskip

\noindent We define a function $\mffit : \typeset \rightarrow \mfset \rightarrow \powerset{\funcset}$ as follows:
\begin{equation*}
	\mffit(t)((\wildcard, F)) = \{ f \in F \mid \funcin(f) \geq t \}
\end{equation*}

\noindent That is, we look at all functions $f \in F$ and choose only those whose input type is a supertype of the given argument type $t$. We choose the supertyping relation and not the subtyping relation, because a function may be called with more specific argument types than the function expects.

\begin{example}
	Suppose we have the multi-function $\mathcal{F}_\idval{concat}$. We get the following results when applying $\mffit$:
	\begin{equation*}
		\mffit(\type{(String, String)})(\mathcal{F}_\idval{concat}) = \{ f_1 \}
	\end{equation*}	
	
	\noindent Only $f_1$ is chosen, because $\type{List[a]}$ is not a supertype of $\type{String}$ and neither is $\type{LinkedList[a]}$. $\type{ToString}$ is a supertype of $\type{String}$, since there is an implementation of $\mathtt{toString}$ for $\type{String}$. 
	
	\medskip
	
	\noindent Consider the next application of $\mffit$:
	\begin{equation*}
		\mffit(\type{(LinkedList[Int], List[Int])})(\mathcal{F}_\idval{concat}) = \{ f_1, f_2 \}
	\end{equation*}
	
	\noindent Here, we choose $f_1$ and $f_2$, because the input types of both functions are supertypes of the argument types. $f_3$ is not chosen, since $\type{LinkedList[a]} \not\geq \type{List[a]}$ in the second argument type.
	
	\medskip
	
	\noindent Finally, let's consider the following application:
	\begin{equation*}
		\mffit(\type{(LinkedList[Int], LinkedList[Int] \& Sorted)})(\mathcal{F}_\idval{concat}) = \{ f_1, f_2, f_3 \}
	\end{equation*}
	
	\noindent We choose all three functions, because $\type{ToString} > \type{List[a]} > \type{LinkedList[a]}$ and $ \type{LinkedList[a]} > \type{LinkedList[a] \& Sorted}$. The latter is true, because the intersection with $\type{Sorted}$ makes the $\type{LinkedList[a]}$ type more specific.
\end{example}


\noindent Let $\mfmin : \powerset{\funcset} \rightarrow \powerset{\funcset}$ be the function defined as follows:
\begin{align*}
	\mfmin(B) = \{ f \in B \mid (\funcin(f') \comparable \funcin(f)) \implies \funcin(f') \geq \funcin(f) \text{, for } f' \in B \}
\end{align*}

\noindent That is, $\mfmin$ is a function that extracts the most specific functions from a multi-function fit. Note that there may be multiple such functions, if their input types are not comparable, or none at all, if the fit is empty. We will explore both cases in the next example.

\begin{example}
	
\end{example}





\todo{Intersections with semantic types can be used to define a state, as used in Papyrus script (https://www.creationkit.com/index.php?title=States_(Papyrus)).}

