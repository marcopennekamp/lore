\chapter{Multi-Functions}

Functions of the same name belong to an accordingly named set of functions. Such a function set is called a \textit{multi-function}. A function that belongs to a multi-function is also called an \textit{instance} of that multi-function. Multi-functions can be called like ordinary functions. The actual function being called is chosen at runtime as the function that is most specific in the set of functions fulfilling the subtyping relation comparing the actual (dynamic) argument types with each function's parameter types. We call this kind of invocation \textit{multiple dispatch}. 

Multi-Functions are useful, because they allow functions to be implemented with varying levels of generality. They lend themselves well to a varying ensemble of features and concerns:
\begin{itemize}
	\item \textbf{Ad-hoc Polymorphism} is supported natively, since multiple dispatch is a superset of single dispatch, which is used to implement ad-hoc polymorphism in object-oriented languages.
	\item \textbf{Intersection Types} composed of component, interface or semantic types can be used to define a sufficiently specific type for a given operation. Furthermore, varying degrees of increasingly specific intersection types can be used to specialise a function in different ways. This sufficiently specific type can be used to implement a function which would otherwise have been confined to a class hierarchy in object-oriented programming, thus sacrificing flexibility.
	\item \textbf{Dynamic specialisation and generalisation} of values can be used to specialise or generalise\footnote{Of course supposing that the generalised type still satisfies the type boundaries that its value is subject to.} the type of a value at \textit{runtime}. Since the actual function being called is chosen at runtime when calling a multi-function, we can write functions that implement an operation for a given specialised type.
	\item \textbf{Extendability} is improved by the ability to define multi-functions \textit{across} files and compilation units. This supports features such as C$^\sharp$'s extension methods or Scala's implicit classes in a more concise way.
\end{itemize}

\noindent In this chapter, we will look at the the syntax of function declarations and define functions and multi-functions. After laying out the basics, we will define the rules of multiple dispatch and examine edge cases. We will see how ad-hoc polymorphism, intersection types and dynamic specialisation/generalisation can be used as proposed above.



\section{Functions and Multi-Functions}

\begin{grammar}
\nt{func-def} &\produce \rh{\nt{func-head} = \nt{expr}} \\
\nt{func-head} &\produce \rh{\tn{function} \nt{id}\lpar\nt{func-params}\rpar [\tn{:} \nt{type}]\once} \\
\nt{func-params} &\produce \rh{\nt{func-param} [\tn{,} \nt{func-param}]\onceplus} \\
&\alt \rh{\nt{func-param}\once} \\
\nt{func-param} &\produce \rh{\nt{id} [\tn{:} \nt{type}]\once}
\end{grammar}

\begin{definition}
	A \textbf{function} $f$ is a mapping from an input type $\funcin(f)$ to an output type $\funcout(f)$. Each function has a name, which we denote $\funcname(f)$. Note that the $\nt{id}$ of a function is not necessarily equal to its full name.\todo{Read more here...} The $\funcbody(f)$ of a function is an expression $e = \funcbody(f)$. The type of $e$ must be a subtype of $\funcout(f)$.

	The input type of a function $f$ is defined as follows: Let $[\tau_1, ..., \tau_n]$ be the list of parameter types for each parameter $p_i \in \{ 1, ..., n \}$. Then we have $\funcin(f) = (\tau_1, ..., \tau_n)$, i.e. an n-tuple over the list of parameter types.

	We denote the set of all possible functions as $\funcset$.
\end{definition}

\noindent Consider the following definition for a function add:
\begin{lstlisting}
function add(a: Int, b: Int): Int = a + b
\end{lstlisting}
	
\noindent We will call the defined function $f$. We have the following properties:
\begin{align*}
	\funcname(f) &= \idval{add} \\
	\funcin(f) &= \type{(Int, Int)} \\
	\funcout(f) &= \type{Int} \\
	\funcbody(f) &= \expr{a + b}
\end{align*}

\begin{definition}
	A \textbf{multi-function} is a 2-tuple $\mathcal{F} = (n, F)$ where:
	\begin{itemize}
		\item $n$ is the name of the multi-function.
		\item $F$ is the set of functions belonging to the multi-function.
	\end{itemize}

	\noindent We define $F$ as follows: $F = \{ f \in \funcset \mid \funcname(f) = n \}$
\end{definition}

\noindent That is, a multi-function is a set of functions that share the same name. By convention, we sometimes write $f \in \mathcal{F}$ for $f \in F$. A function $f \in \mathcal{F}$ is also called an \textbf{instance} of $\mathcal{F}$. We denote the set of multi-functions as $\mfset$.

\bigskip

\noindent Consider the following function definitions:
\begin{lstlisting}
function concat(x: ToString, y: ToString) = ... // f1
function concat(x: List[a], y: List[a]) = ... // f2
function concat(x: LinkedList[a], y: LinkedList[a]) = ... // f3
\end{lstlisting}
	
\noindent Assuming no other function with the name \idval{concat} exists, we have the multi-function $\mathcal{F}_\idval{concat} = (\idval{concat}, F)$, where $F = \{ f_1, f_2, f_3 \}$ is the set of \idval{concat} functions defined above.



\section{Multiple Dispatch}

To define multiple dispatch formally, we first need an operation that allows us to reduce the set of multi-function instances to only those functions that could be called with a given tuple of arguments.

\todo{What about output types?}

\todo{How can we support contravariant parameter types seen in object-oriented programming? Should we allow the declaration of "non-dispatch" parameters that won't be used for multiple dispatch and can thus be contravariant?}

\todo{We should look at type parameters and include them in the dispatch. See: https://docs.julialang.org/en/release-0.4/manual/methods/#parametric-methods}

\begin{definition}
	We define a function $\mffit : \typeset \rightarrow \mfset \rightarrow \powerset{\funcset}$ as follows:
	\begin{equation*}
		\mffit(t)(\mathcal{F}) = \{ f \in \mathcal{F} \mid \funcin(f) \geq t \}
	\end{equation*}
\end{definition}

\noindent That is, we look at all functions $f \in F$ and choose only those whose input type is a supertype of the given argument type $t$. We can not choose functions that have a more specific input type than the given argument type, because we need to call that function with valid arguments. We take functions with a more general input type into account, because such a function can be called with a subtype of the input type, i.e. with more specific arguments than needed.

\medskip

\noindent Suppose we have the multi-function $\mathcal{F}_\idval{concat}$. We get the following results when applying $\mffit$:
\begin{equation*}
	\mffit(\type{(String, String)})(\mathcal{F}_\idval{concat}) = \{ f_1 \}
\end{equation*}	
	
\noindent Only $f_1$ is chosen, because $\type{List[a]}$ is not a supertype of $\type{String}$ and neither is $\type{LinkedList[a]}$. $\type{ToString}$ is a supertype of $\type{String}$, since there is an implementation of $\mathtt{toString}$ for $\type{String}$. 
	
\medskip
	
\noindent Consider the next application of $\mffit$:
\begin{equation*}
	\mffit(\type{(LinkedList[Int], List[Int])})(\mathcal{F}_\idval{concat}) = \{ f_1, f_2 \}
\end{equation*}
	
\noindent Here, we choose $f_1$ and $f_2$, because the input types of both functions are supertypes of the argument types. $f_3$ is not chosen, since $\type{LinkedList[a]} \not\geq \type{List[a]}$ in the second argument type.
	
\medskip
	
\noindent Finally, let's consider the following application:
\begin{equation*}
	\mffit(\type{(LinkedList[Int], LinkedList[Int] \& Sorted)})(\mathcal{F}_\idval{concat}) = \{ f_1, f_2, f_3 \}
\end{equation*}
	
\noindent We choose all three functions, because $\type{ToString} > \type{List[a]} > \type{LinkedList[a]}$ and $ \type{LinkedList[a]} > \type{LinkedList[a] \& Sorted}$. The latter is true, because the intersection with $\type{Sorted}$ makes the $\type{LinkedList[a]}$ type more specific.


\begin{definition}
	Let $\mfmin : \powerset{\funcset} \rightarrow \powerset{\funcset}$ be the function defined as follows:
	\begin{align*}
		\mfmin(B) = \{ f \in B \mid (\funcin(f') \comparable \funcin(f)) \implies \funcin(f') \geq \funcin(f) \text{, for } f' \in B \}
	\end{align*}
\end{definition}

\noindent That is, $\mfmin$ is a function that extracts the most specific functions from a multi-function fit. Note that there may be multiple such functions, if their input types are not comparable, or none at all, if the fit is empty. We will explore both cases in the next example.

We will first look at an example with the multi-function $\mathcal{F}_\idval{concat}$. Suppose we have a fit $B = \{ f_1, f_2 \}$. We apply $\mfmin$ as follows:
\begin{equation*}
	Min(\{ f_1, f_2 \}) = \{ f_2 \} \text{, because } f_1 > f_2
\end{equation*}
	
\noindent A set with exactly one element is \textit{the} result that we need for multiple dispatch to be applicable. If the set was empty, we would not have found a suitable function to call. Perhaps even worse, if the set contains more than one element, we have an ambiguity and can not decide which function should be called. The following example shows that such an ambiguity exists.

\medskip
	
\noindent Assume we have the following two functions:
\begin{lstlisting}
function area(x: Circle) = pi * x.radius * x.radius // f1
function area(x: +BoundingBox) = { // f2
  val b = x.BoundingBox
  val width = b.maxX - b.minX
  val height = b.maxY - b.minY
  width * height
} 
\end{lstlisting}
	
\noindent That is, we can calculate the area both for a circle and for an object that has a BoundingBox component.\footnote{This is not a particularly nice example, since a BoundingBox should not be used to calculate an area, but let's just say that some incredibly wacky programmer decided to go with it.} We call the associated multi-function $\mathcal{F}_{\idval{area}}$. Now, what about a Circle that has a BoundingBox as a component? In other words, suppose we call the multi-function $\mathcal{F}_{\idval{area}}$ with an argument of the type $t = \type{Circle \& +BoundingBox}$. We have the following properties:
\begin{align*}
	B = Fit(t)(\mathcal{F}_{\idval{area}}) &= \{ f_1, f_2 \} \\
	Min(B) &= \{ f_1, f_2 \}
\end{align*}
	
\noindent The first result comes from the fact that for any types \type{a} and \type{b}, it holds that $\type{a} \geq \type{a \& b}$, and thus $\type{Circle} \geq \type{Circle \& +BoundingBox}$, as well as $\type{+BoundingBox} \geq \type{Circle \& +BoundingBox}$.
	
The second result is due to the fact that \type{Circle} and \type{+BoundingBox} are \textit{incomparable}, i.e. $\type{Circle} \incomparable +BoundingBox$, since the two types are neither equal, nor is one less or greater than the other.
	
Since the most specific function is not unique, we should abort the compilation with an error (preferably) or even exit the program with a runtime error. We could call all associated functions, but this is likely not intended by the developer (and would thus only make sense if we make the programmer use a keyword at the call-site to switch the feature on), it's also not clear how to aggregate the return types and finally the call order of the functions is not determined.
	
There are other instances of such an ambiguity, especially involving multiple function parameters (e.g. \type{(Int, a)} vs. \type{(a, Int)}), but the example above should be sufficient to illustrate the concept.
	
\medskip
	
\noindent In closing the example, we will look at the conditions needed to produce an empty fit. Let's assume we calculate the fit for a type $t = \type{Rectangle}$ in the multi-function $\mathcal{F}_{\idval{area}}$. Provided that Rectangle does not have a BoundingBox component, the fit will be empty, because neither \type{Circle} nor \type{+BoundingBox} are a supertype of \type{Rectangle}.




\todo{Intersections with semantic types can be used to define a state, as used in Papyrus script (https://www.creationkit.com/index.php?title=States_(Papyrus)).}

