\chapter{Multi-Functions}

Functions of the same name belong to an accordingly named set of functions. Such a function set is called a \textit{multi-function}. A function that belongs to a multi-function is also called an \textit{instance} of that multi-function. Multi-functions can be called like ordinary functions. The actual function being called is chosen at runtime as the function that is most specific regarding the subtyping relation comparing the actual (dynamic) argument types with its parameter types. We call this kind of invocation \textit{multiple dispatch}. 

Multi-Functions are useful, because they allow functions to be implemented with varying levels of generality. They lend themselves well to a varying ensemble of features and concerns:
\begin{itemize}
	\item \textbf{Ad-hoc Polymorphism} is supported natively, since multiple dispatch is a superset of single dispatch, which is used to implement ad-hoc polymorphism in object-oriented languages.
	\item \textbf{Intersection Types} composed of component, interface or semantic types can be used to define a sufficiently specific type for a given operation. Furthermore, varying degrees of increasingly specific intersection types can be used to specialise a function in different ways. This sufficiently specific type can be used to implement a function which would otherwise have been confined to a class hierarchy in object-oriented programming, thus sacrificing flexibility.
	\item \textbf{Dynamic specialisation and generalisation} of values can be used to specialise or generalise\footnote{Of course supposing that the generalised type still satisfies the type boundaries that its value is subject to.} the type of a value at \textit{runtime}. Since the actual function being called is chosen at runtime when calling a multi-function, we can write functions that implement an operation for a given specialised type.
	\item \textbf{Extendability} is improved by the ability to define multi-functions \textit{across} files and compilation units. This supports features such as C$^\sharp$'s extension methods or Scala's implicit classes in a more concise way.
\end{itemize}

\noindent In this chapter, we will look at the the syntax of function declarations and define functions and multi-functions. After laying out the basics, we will define the rules of multiple dispatch and examine edge cases. We will see how ad-hoc polymorphism, intersection types and dynamic specialisation/generalisation can be used as proposed above.



\section{Functions and Multi-Functions}

\begin{grammar}
\nt{func-def} &\produce \rh{\nt{func-head} = \nt{expr}} \\
\nt{func-head} &\produce \rh{\tn{function} \nt{id}\lpar\nt{func-params}\rpar [\tn{:} \nt{type}]\once} \\
\nt{func-params} &\produce \rh{\nt{func-param} [\tn{,} \nt{func-param}]\onceplus} \\
&\alt \rh{\nt{func-param}\once} \\
\nt{func-param} &\produce \rh{\nt{id} [\tn{:} \nt{type}]\once}
\end{grammar}

\noindent A \textbf{function} $f$ is a mapping from an input type $in(f)$ to an output type $out(f)$. Each function has a name, which we denote $name(f)$. Note that the $\nt{id}$ of a function is not necessarily equal to its full name.\todo{Read more here...} The body $body(f)$ of the function is defined by an expression $e = body(f)$, which must be a subtype of $out(f)$.

The input type of a function $f$ is defined as follows: Let $[\tau_1, ..., \tau_n]$ be the list of parameter types for each parameter $p_i \in \{ 1, ..., n \}$. Then we have $in(f) = (\tau_1, ..., \tau_n)$, i.e. an n-tuple over the list of parameter types.

We denote the set of all possible functions as $\textsc{Func}$.

\bigskip

\noindent A \textbf{multi-function} $\mathcal{F}$ is defined as follows, where $name(\mathcal{F})$ denotes its name:
\begin{equation*}
	\mathcal{F} = \{ f \in \textsc{Func} \mid name(f) = name(\mathcal{F}) \}
\end{equation*}

\noindent That is, a multi-function is a set of functions that share the same name. A function $f \in \mathcal{F}$ is also called an \textbf{instance} of $\mathcal{F}$.





\todo{Intersections with semantic types can be used to define a state, as used in Papyrus script (https://www.creationkit.com/index.php?title=States_(Papyrus)).}

