\chapter{Multi-Functions}

Functions of the same name belong to an accordingly named set of functions. Such a function set is called a \textit{multi-function}. A function that belongs to a multi-function is also called an \textit{instance} of that multi-function. Multi-functions can be called like ordinary functions. The actual function being called is chosen at runtime as the function that is most specific in the set of functions fulfilling the subtyping relation comparing the actual (dynamic) argument types with each function's parameter types. We call this kind of invocation \textit{multiple dispatch}. 

Multi-Functions are useful, because they allow functions to be implemented with varying levels of generality. They lend themselves well to a varying ensemble of features and concerns:
\begin{itemize}
	\item \textbf{Ad-hoc Polymorphism} is supported natively, since multiple dispatch is a superset of single dispatch, which is used to implement ad-hoc polymorphism in object-oriented languages.
	\item \textbf{Intersection Types} composed of component, interface or semantic types can be used to define a sufficiently specific type for a given operation. Furthermore, varying degrees of increasingly specific intersection types can be used to specialise a function in different ways. This sufficiently specific type can be used to implement a function which would otherwise have been confined to a class hierarchy in object-oriented programming, thus sacrificing flexibility.
	\item \textbf{Dynamic specialisation and generalisation} of values can be used to specialise or generalise\footnote{Of course supposing that the generalised type still satisfies the type boundaries that its value is subject to.} the type of a value at \textit{runtime}. Since the actual function being called is chosen at runtime when calling a multi-function, we can write functions that implement an operation for a given specialised type.
	\item \textbf{Extendability} is improved by the ability to define multi-functions \textit{across} files and compilation units. This supports features such as C$^\sharp$'s extension methods or Scala's implicit classes in a more concise way.
\end{itemize}

\noindent In this chapter, we will look at the the syntax of function declarations and define functions and multi-functions. After laying out the basics, we will define the rules of multiple dispatch and examine edge cases. We will see how ad-hoc polymorphism, intersection types and dynamic specialisation and generalisation can be used as proposed above. 



\section{Functions and Multi-Functions}

\begin{grammar}
\nt{func-def} &\produce \rh{\nt{func-head} [= \nt{expr}]\once} \\
\nt{func-head} &\produce \rh{\tn{function} \nt{id}\lpar\nt{func-params}\rpar [\tn{:} \nt{type}]\once} \\
\nt{func-params} &\produce \rh{\nt{func-param} [\tn{,} \nt{func-param}]\onceplus} \\
&\alt \rh{\nt{func-param}\once} \\
\nt{func-param} &\produce \rh{\nt{id} [\tn{:} \nt{type}]\once}
\end{grammar}

\begin{definition}
	A \textbf{function} $f$ is a mapping from an input type $\funcin(f)$ to an output type $\funcout(f)$. Each function has a name, which we denote $\funcname(f)$. Note that the $\nt{id}$ of a function is not necessarily equal to its full name.\todo{Read more here...} The $\funcbody(f)$ of a function is an expression $\funcbody(f)$. The type of $\funcbody(f)$ must be a subtype of $\funcout(f)$. The body may be empty, in which case we write $\funcbody(f) = \none$ and call the function \textit{abstract}. An abstract function may not be called at run-time.

	The input type of a function $f$ is defined as follows: Let $[\tau_1, ..., \tau_n]$ be the list of parameter types for each parameter $p_i \in \{ 1, ..., n \}$. Then we have $\funcin(f) = (\tau_1, ..., \tau_n)$, i.e. an n-tuple over the list of parameter types.

	We denote the set of all possible functions as $\funcset$.
\end{definition}

\noindent Consider the following definition for a function add:
\begin{lstlisting}
function add(a: Int, b: Int): Int = a + b
\end{lstlisting}
	
\noindent We will call the defined function $f$. We have the following properties:
\begin{align*}
	\funcname(f) &= \idval{add} \\
	\funcin(f) &= \type{(Int, Int)} \\
	\funcout(f) &= \type{Int} \\
	\funcbody(f) &= \expr{a + b}
\end{align*}

\begin{definition}
	A \textbf{multi-function} is a 2-tuple $\mathcal{F} = (n, F)$ where:
	\begin{itemize}
		\item $n$ is the name of the multi-function.
		\item $F$ is the set of functions belonging to the multi-function.
	\end{itemize}

	\noindent We define $F$ as follows: $F = \{ f \in \funcset \mid \funcname(f) = n \}$
\end{definition}

\noindent That is, a multi-function is a set of functions that share the same name. By convention, we sometimes write $f \in \mathcal{F}$ for $f \in F$. A function $f \in \mathcal{F}$ is also called an \textbf{instance} of $\mathcal{F}$. We denote the set of multi-functions as $\mfset$.

\bigskip

\noindent Consider the following function definitions:
\begin{lstlisting}
function concat(x: ToString, y: ToString) = ... // f1
function concat(x: List[a], y: List[a]) = ... // f2
function concat(x: LinkedList[a], y: LinkedList[a]) = ... // f3
\end{lstlisting}
	
\noindent Assuming no other function with the name \idval{concat} exists, we have the multi-function $\mathcal{F}_\idval{concat} = (\idval{concat}, F)$, where $F = \{ f_1, f_2, f_3 \}$ is the set of \idval{concat} functions defined above.



\section{Multiple Dispatch}

To define multiple dispatch formally, we first need an operation that allows us to reduce the set of multi-function instances to only those functions that could be called with a given tuple of arguments.

\todo{We should look at type parameters and include them in the dispatch. See: https://docs.julialang.org/en/release-0.4/manual/methods/#parametric-methods}

\todo{How do we treat functions with the same name but a different amount of parameters?}

\begin{definition}
	We define a function $\mffit : \typeset \rightarrow \mfset \rightarrow \powerset{\funcset}$ as follows:
	\begin{equation*}
		\mffit(t)(\mathcal{F}) = \{ f \in \mathcal{F} \mid \funcin(f) \geq t \}
	\end{equation*}
\end{definition}

\noindent That is, we look at all functions $f \in F$ and choose only those whose input type is a supertype of the given argument type $t$. We can not choose functions that have a more specific input type than the given argument type, because we need to call that function with valid arguments. We take functions with a more general input type into account, because such a function can be called with a subtype of the input type, i.e. with more specific arguments than needed.

\medskip

\noindent Suppose we have the multi-function $\mathcal{F}_\idval{concat}$. We get the following results when applying $\mffit$:
\begin{equation*}
	\mffit(\type{(String, String)})(\mathcal{F}_\idval{concat}) = \{ f_1 \}
\end{equation*}	
	
\noindent Only $f_1$ is chosen, because $\type{List[a]}$ is not a supertype of $\type{String}$ and neither is $\type{LinkedList[a]}$. $\type{ToString}$ is a supertype of $\type{String}$, since there is an implementation of $\mathtt{toString}$ for $\type{String}$. 
	
\medskip
	
\noindent Consider the next application of $\mffit$:
\begin{equation*}
	\mffit(\type{(LinkedList[Int], List[Int])})(\mathcal{F}_\idval{concat}) = \{ f_1, f_2 \}
\end{equation*}
	
\noindent Here, we choose $f_1$ and $f_2$, because the input types of both functions are supertypes of the argument types. $f_3$ is not chosen, since $\type{LinkedList[a]} \not\geq \type{List[a]}$ in the second argument type.
	
\medskip
	
\noindent Finally, let's consider the following application:
\begin{equation*}
	\mffit(\type{(LinkedList[Int], LinkedList[Int] \& Sorted)})(\mathcal{F}_\idval{concat}) = \{ f_1, f_2, f_3 \}
\end{equation*}
	
\noindent We choose all three functions, because $\type{ToString} > \type{List[a]} > \type{LinkedList[a]}$ and $ \type{LinkedList[a]} > \type{LinkedList[a] \& Sorted}$. The latter is true, because the intersection with $\type{Sorted}$ makes the $\type{LinkedList[a]}$ type more specific.


\begin{definition} \label{def:mfmin}
	Let $\mfmin : \powerset{\funcset} \rightarrow \powerset{\funcset}$ be the function defined as follows:
	\begin{align*}
		\mfmin(B) = \{ f \in B \mid (\funcin(f') \comparable \funcin(f)) \implies \funcin(f') \geq \funcin(f) \text{, for } f' \in B \}
	\end{align*}
\end{definition}

\noindent That is, $\mfmin$ is a function that extracts the most specific functions from a multi-function fit. Note that there may be multiple such functions, if their input types are not comparable, or none at all, if the fit is empty. We will explore both cases in the next example.

We will first look at an example with the multi-function $\mathcal{F}_\idval{concat}$. Suppose we have a fit $B = \{ f_1, f_2 \}$. We apply $\mfmin$ as follows:
\begin{equation*}
	Min(\{ f_1, f_2 \}) = \{ f_2 \} \text{, because } f_1 > f_2
\end{equation*}
	
\noindent A set with exactly one element is \textit{the} result that we need for multiple dispatch to be applicable. If the set was empty, we would not have found a suitable function to call. Perhaps even worse, if the set contains more than one element, we have an ambiguity and can not decide which function should be called. The following example shows that such an ambiguity exists.

\medskip
	
\noindent Assume we have the following two functions:
\begin{lstlisting}
function area(x: Circle) = pi * x.radius * x.radius // f1
function area(x: +BoundingBox) = { // f2
  val b = x.BoundingBox
  val width = b.maxX - b.minX
  val height = b.maxY - b.minY
  width * height
} 
\end{lstlisting}
	
\noindent That is, we can calculate the area both for a circle and for an object that has a BoundingBox component.\footnote{This is not a particularly nice example, since a BoundingBox should not be used to calculate an area, but let's just say that some incredibly wacky programmer decided to go with it.} We call the associated multi-function $\mathcal{F}_{\idval{area}}$. Now, what about a Circle that has a BoundingBox as a component? In other words, suppose we call the multi-function $\mathcal{F}_{\idval{area}}$ with an argument of the type $t = \type{Circle \& +BoundingBox}$. We have the following properties:
\begin{align*}
	B = Fit(t)(\mathcal{F}_{\idval{area}}) &= \{ f_1, f_2 \} \\
	Min(B) &= \{ f_1, f_2 \}
\end{align*}
	
\noindent The first result comes from the fact that for any types \type{a} and \type{b}, it holds that $\type{a} \geq \type{a \& b}$, and thus $\type{Circle} \geq \type{Circle \& +BoundingBox}$, as well as $\type{+BoundingBox} \geq \type{Circle \& +BoundingBox}$.
	
The second result is due to the fact that \type{Circle} and \type{+BoundingBox} are \textit{incomparable}, i.e. $\type{Circle} \incomparable +BoundingBox$, since the two types are neither equal, nor is one less or greater than the other.
	
Since the most specific function is not unique, we should abort the compilation with an error (preferably) or even exit the program with a runtime error. We could call all associated functions, but this is likely not intended by the developer (and would thus only make sense if we make the programmer use a keyword at the call-site to switch the feature on), it's also not clear how to aggregate the return types and finally the call order of the functions is not determined.
	
There are other instances of such an ambiguity, especially involving multiple function parameters (e.g. \type{(Int, a)} vs. \type{(a, Int)}), but the example above should be sufficient to illustrate the concept.
	
\medskip
	
\noindent In closing the example, we will look at the conditions needed to produce an empty fit. Let's assume we calculate the fit for a type $t = \type{Rectangle}$ in the multi-function $\mathcal{F}_{\idval{area}}$. Provided that Rectangle does not have a BoundingBox component, the fit will be empty, because neither \type{Circle} nor \type{+BoundingBox} are a supertype of \type{Rectangle}.

\bigskip

\noindent Having defined the $\mffit$ and $\mfmin$ functions, we can finally turn our attention to defining \textit{multi-function calls}.

\begin{definition}
	Suppose we have a function call expression as follows:
	\begin{equation*}
		N(e_1, ..., e_n)
	\end{equation*}
	
	\noindent A \textbf{multi-function call} is an operation with the following compile-time constraints and run-time semantics: Let $\mathcal{F}$ be the multi-function with the name $N$. Let $t = (t_1, ..., t_n)$ with $e_1 : t_1, ..., e_n : t_n$ be the tuple type of the arguments. Let $B = \mffit(t)(\mathcal{F})$ be the fit of $\mathcal{F}$. Let $C = \mfmin(B)$ be the set of most specific functions in the fit $B$. 
	
	At \textit{compile-time}, we need to check whether the function to call would be unique if the run-time argument type was $t$. That is, if the run-time argument type would match the type bound $t$ exactly. We distinguish the following cases:
	\begin{itemize}
		\item If $C = \emptyset$, there is no function that fits the argument type. Thus, we throw an \textit{empty-fit} error.
		\item If $C = \{ f \}$, that is, there is exactly one most specific function, the multi-function call passes the compile-time check.
		\item If $C = \{ f_1, ..., f_k \}$ for $k \geq 2$, that is, we have an ambiguity, we throw an \textit{ambiguous-call} error.
	\end{itemize}
	
	\noindent At \textit{run-time}, the actual argument types might specialise the compile-time type bound $t$. Let $t' = (t'_1, ..., t'_n)$ be the run-time argument tuple type. Let $B' = \mffit(t')(\mathcal{F})$ and $C' = \mfmin(B')$. Since $C' \neq \emptyset$ at run-time\footnote{The \textit{empty-fit} error is always caught at compile-time. Refer to section \ref{section:empty-fit-ambiguous-call} for a proof.}, we only distinguish two cases:
	\begin{itemize}
		\item If $C = \{ f \}$, we call the function $f$, unless it is abstract, in which case we throw an \textit{abstract-call} error.
		\item If $C = \{ f_1, ..., f_k \}$ for $k \geq 2$, we throw an \textit{ambiguous-call} error.
	\end{itemize}
\end{definition}

\noindent Note that we have to distinguish between compile-time and run-time errors, which we will talk more about in the next section. Also note that the compile-time constraints do not refer to the abstractness of the function $f$, since the point of an abstract function is exactly that the compile-time checks pass while we require specialisation of the argument types at runtime.



\section{Empty-Fit and Ambiguous-Call Errors} \label{section:empty-fit-ambiguous-call}

In the definition of \textit{multi-function calls} we had to distinguish between compile-time and run-time errors. In particular, we defined the \textit{empty-fit} error as compile-time-only, while the \textit{ambiguous-call} error may either occur at compile-time or run-time. Of course, compile-time errors are always preferable to run-time errors. However, with the expressiveness of the type system of Lore, we can not get around the possibility of a run-time error for the ambiguity case. We will see why in this section.

\bigskip

\noindent First, we will look at the compile-time-only property of the \textit{empty-fit} error. We will prove that the error must only occur at compile-time by looking at a call of a multi-function $\mathcal{F}$. Let $t$ be the tuple type of the argument values deduced at compile-time. Let $B = \mffit(t)(\mathcal{F})$ and $C = \mfmin(B)$. Let's assume we call the multi-function at run-time with an argument type $t'$. Let $B' = \mffit(t')(\mathcal{F})$ and $C' = \mfmin(B')$. 

Assume that $C' = \emptyset$, but $|C| = 1$.\footnote{We can safely assume that $|C| \leq 2$, since otherwise the code would not compile because of an ambiguity error.} That is, calling the multi-function at compile-time was valid, but we can't find any fitting function to call at run-time. Since $C \neq \emptyset$, we have $B \neq \emptyset$, so there exists an $f \in B$ such that $\funcin(f) \geq t$ (by definition of the fit). Now, we observe that $t'$ specialises the argument type $t$, so that $t \geq t'$ holds. This is the only way in which the run-time type of the argument can change. In particular, $t$ can not be generalised, because it is the upper-bound for any actual argument types and thus generalising $t$ would lead to a type-checking error. From $t \geq t'$, it follows, by transitivity of the subtyping relation, that $\funcin(f) \geq t'$ and thus $f \in B'$ (by definition of the fit). Finally, we can derive that $f \in C'$, which contradicts $C' = \emptyset$. Thus we have proven that the \textit{empty-fit} error can only occur at compile-time.

\bigskip

Moving on to the \textit{ambiguous-call} error, we can show with a simple example that such an error might only be caught at run-time. Let's look at the ambiguity example below definition \ref{def:mfmin} again. We have two functions $f_1 : \type{Circle \fto Real}$ and $f_2 : \type{+BoundingBox \fto Real}$. At compile-time, in an expression $\idval{area}(c)$, $f_2$ is the unique most specific function to call given a variable $c : \type{+BoundingBox}$. Since $\type{Circle \& +BoundingBox}$ is a subtype of $\type{+BoundingBox}$, we may safely pass such an argument at run-time. The problem is that the additional intersection type allows both \texttt{area}-functions to be called, as can be seen in the original example, instead of only the one that takes a \type{+BoundingBox} argument. This leads to an ambiguity error at \textit{run-time}.

More generally, we can observe that intersection types are precisely the feature that make our version of multiple dispatch ambiguous.\todo{Proof needed.} If we have two functions $f_1 : \type{t1}$ and $f_2 : \type{t2}$ that have the same name, we can introduce a run-time ambiguity with the intersection type \type{t1 \& t2}.



\section{Constraints on Return Types}

So far we have only talked about \textit{parameter types} of multi-function instances. We also have to account for return types of functions, because we must ensure type safety.

First of all, we can not incorporate the return type into the multiple dispatch process. Doing so would jeopardise our type inference mechanism, which will frequently rely on function return types. To ensure type safety, we will impose a constraint on return types.

\begin{definition}
	Let $\mathcal{F}$ be a multi-function. The following \textbf{constraint on return types} must be satisfied for all $f, f' \in \mathcal{F}$:
	\begin{equation*}
		\funcin(f) \geq \funcin(f') \implies \funcout(f) \geq \funcout(f')
	\end{equation*}
\end{definition}

\noindent That is, assume $f'$ specialises $f$. If we have a value $v$ with a compile-time type of $\funcin(f)$ in a function call expression $f(v)$, we can assume a return type of $\funcout(f)$. Since $f'$ is called instead of $f$ if $v$ is run-time specialised to $\funcin(f')$, we must ensure that the return type of $f'$ satisfies the type bound $\funcout(f)$. Otherwise, a value might be returned that does not fit the type that was deemed valid at compile-time.

If a multi-function fails to satisfy this constraint, an \textit{invalid-return-type} error will be thrown at compile-time, mentioning all offending function definitions.



\section{Abstract Function Constraints and Usage}

We want abstract functions to provide a guarantee that a multi-function call always finds a non-abstract function to call at run-time. More precisely, we define a constraint on abstract functions called the \textbf{totality constraint}.

\begin{definition}
	Let $\mathcal{F}$ be a multi-function. The following \textbf{totality constraint} $T(f)$ must be satisfied for all abstract functions $f \in \mathcal{F}$ and all \textit{direct}\footnote{We define a direct subtype $s$ of a type $t$ as a type $s < t$, such that there is no type $r$ with $s < r < t$.} subtypes $s$ of $\funcin(f)$:
	\begin{equation*}
		\exists f' \in \mathcal{F}.\; \funcin(f') = s \land (\funcbody(f') = \none \lor T(f'))
	\end{equation*}
\end{definition}

\noindent That is, for all \textit{direct} subtypes of $\funcin(f)$, there needs to be an implemented function ($\funcbody(f') = \none$) \textit{unless} the function call can be deferred to an abstract function $f'$, in which case $f'$ has to satisfy the totality constraint.

If a multi-function $\mathcal{F}$ does not satisfy the totality constraint, a \textit{missing-implementation} error is thrown, which includes a list of input types that need to be covered.

\medskip

\noindent Functions with an abstract input type must be abstract functions, which is formalised in the following definition.

\begin{definition}
	Let $\mathcal{F}$ be a multi-function. The following condition must be satisfied for all functions $f \in \mathcal{F}$: If the type $\funcin(f)$ is abstract, i.e. not instantiable, then $f$ must be abstract, i.e. $\funcbody(f) = \none$.
\end{definition}

\medskip

\todo{Usage example: Suppose we have a union type T = A | B. We write two functions f : A -> X and f : B -> X. But since calling f(v) with v : T does not give us any function in the fit, because both defined functions are too specific for the general type T, we need to be able to define a more general function that does not need an implementation itself, i.e. abstract functions.}



\todo{Intersections with semantic types can be used to define a state, as used in Papyrus script (https://www.creationkit.com/index.php?title=States_(Papyrus)).}

