# Classes, Entities, and Components

[Previous File](03-multi-functions.md) [Next File](05-expressions.md)

In this document, we consider **classes, entities, and components**.

While classes are hugely important in Lore, the true focus of the language lies on **entities and components**. A component, in short, is a set of properties that is *also* part of a larger entity. It is thus not the component itself which brings the flexibility, but the **combination of multiple components** in one entity. The novelty that I believe Lore brings to the table is that we can define functions over arbitrary combinations of components. We could define a function over a combination `+Position & +HealthState` that is then usable by *all* entities that have these two components. This allows a programmer to separate and mix data in such a way that maximum flexibility can be achieved—I believe this is especially useful for game development, but could be equally useful in general purpose contexts. My job as a language designer is to give you the tools so *you* can figure out the useful contexts.

**A modest list of TODOs:**

- **TODO:** What about attaching components at run-time? We need that feature, but probably not for the first language version. This should be developed hand-in-hand with dynamic specialization.

- **TODO:** How do we create classes that override component types? In general, class property types can't be overridden in subclasses, because properties can both be set and gotten by the parent class. But: Shouldn't classes be covariant in the components they define, as components cannot be swapped out, only set with the constructor? So if a type `Entity3D` has a component `Position3D`, shouldn't a subtype `Entity2D` be able to have a `Position2D`?

- **TODO:** We can make *immutable* properties in general overridable.

- **Idea:** Add a Record data type (or maybe named case class, simple class, struct, etc.), which is akin to case classes in Scala. The user will be able to pattern-match values of this type, which is not possible with classes. A record can't have components, but will be able to become a component of some entity.

  ```
  record Position(x: Real, y: Real, z: Real) {
    derived isOrigin: Boolean = x == y && y == z && z == 0.0
  }
  ```

- **TODO:** Component subtyping leads to a diamond problem. Consider an entity with two components: `CelsiusTemperature` and `FahrenheitTemperature`. Which component is chosen if we want to assign the entity to a variable of type `+Temperature`? This hints that we need to exclude whole hierarchies of types when we consider which components can be mutually part of the same entity.

  - Going further, will we get problems with `Any`? What happens when we assign an entity to `+Any`? (Ouch.)



### Classes

A **class** is a nominal data type defining a set of properties and constructors. Class instances are called objects. The syntax is as follows:

```
class C {
  a: A
  mut b: B
  // constructor syntax defined later
}
const c = C(a, b)
```

A **property** is either *immutable* (denoted without a keyword) or *mutable* (denoted `mut`). Only mutable properties can be modified after the object has been constructed. Properties are **accessed** via the dot notation. See [05-expressions](05-expressions.md).

A **constructor** is a function that creates an instance of the class it's declared within. Constructors are special in that they must be used to create a new instance of a class. There is no other way to define instantiation.

###### Example

```
class Position {
  x: Real
  y: Real
  z: Real
  // Implicit default constructor: Position(x: Real, y: Real, z: Real)
}
```

##### Inheritance

A class `A` may **inherit** from another class `B`. This allows `A` to inherit all properties of `B` and also puts `A` into a subtyping relation `A < B`.

```
class A extends B
```

##### Constructors

Constructors are special functions which can use the **construct** statement. The construct statement takes as arguments all of the class's properties in their order of declaration. For example, the declaration in the introduction would have the associated construct statement `construct(a, b)` for `a: A` and `b: A`. This statement simply assign the given arguments to the properties and thus creates an object. Ultimately, this statement is the only way to *create* a new instance.

Every class has one **default constructor**. If we have a class named `A`, this constructor can be accessed with `A(...)`. This constructor is generated by default, where its parameters are all the class's local properties followed by the arguments of the supertype's default constructor. It can easily be overridden.

Let's look at how we can **define constructors:**

```
class Position {
  // ...
  
  // The following is the default constructor as it is generated.
  Position(x: Real, y: Real, z: Real) {
    construct(x, y, z)
  }
  
  // Note how our constructor syntax doesn't include the equals
  // sign known from function definitions.
  from2D(x: Real, y: Real) {
    this(x, y, 0)
  }
}

Position.from2D(1.0, 1.5) // => Position(1.0, 1.5, 0.0)
```

All non-default constructors have to be **named**. Inside the constructor scope, `this` refers to the default constructor, while `this.from2D` would refer to the constructor named `from2D`. Outside the constructor scope, `Position(...)` refers to the default constructor, while `Position.from2D(…)` refers to the named constructor.

Every constructor has to **terminate** in a `this` or `construct` statement, either deferring to another constructor or constructing the instance. The call must be the last statement in the block, at the top level. (**TODO:** Alternatively, we could throw a run-time error if an object isn't correctly constructed, which would allow for more flexibility in constructor definitions.)

**Construction, not initialization:** A constructor does not have access to object properties or the new instance. A constructor is supposed to *construct* an instance, not *initialize* it. If a class is so complex that it needs to be initialized after a value has been constructed, you should require a separate initialization step. Of course, you can perform arbitrary calculations before the `this`/`construct` call, but you'll have to work with the attributes.

###### Throwing Super into the Mix

Things get slightly more complicated when we consider **superclasses**. For the sake of flexibility, we want to allow calling any superclass constructor in combination with any class constructor. This is possible with an extension to the `construct` statement:

```
class Character {
  name: String
  
  // Just for illustration purposes.
  Character(name: String) {
    construct(name)
  }
  
  fromArchetype(archetype: Archetype) {
    // We defer to the default constructor.
    this(archetype.name)
  }
}

class Player extends Character {
  money: Real
  
  // Again, just for illustration.
  Player(money: Real, name: String) {
    construct(money) with super(name)
  }
  
  // Make sure we call the fromArchetype constructor of Character.
  fromArchetype(archetype: Archetype) {
    construct(0) with super.fromArchetype(archetype)
  }
}
```

We can add a `with super(...)` to the construct statement which allows us to **call any superclass constructor**.

##### Post-MVL Extensions

- **Visibility declarations** like public, private, protected, etc. Whatever we need.

  - It should be possible to make the **default constructor private** so that class users have to use one of the named constructors.

- **Default values** for properties.

- Easy **getters and setters** for properties.

- **Derived properties** are properties that depend on other properties and can't be passed through the constructor. By default, a `derived` property is computed once after all non-derived properties and derived properties ordered before the given property have been initialized. You can also declare a `computed` property that is recomputed every time it is accessed. (Computed may not be the best term for this, however.)

  While derived properties could also be implemented by multi-functions, they provide the ability to define a property about the data that is **invariant** and can't be changed through function specialisation.

  ```
  class RightTriangle {
    a: Real
    b: Real
    derived c: Real = sqrt(pow(a, 2) * pow(b, 2))
  }
  ```

- **Syntactic sugar for functions**, as seen below. These functions would simply be immutable properties that hold an anonymous function. This can be useful in some specific cases, but could also lead to bad code style or confused new language users if these kinds of functions are erroneously preferred over multi-functions. Maybe we shouldn't make it easy to declare such functions.

  ```
  class C {
    function f(a: A): B = ...
    // is the same as
    f: A => B = { a => ... }
  }
  ```

- Some kind of companion object as known from Scala? Or rather **companion namespaces**? (Also see the `namespace Position` declaration in the example below.)

- Allow classes to extend **label types:**

  ```
  class A is Saveable and Sorted
  ```

- **Ad-hoc envelope types:** Lore will support [envelope types](types.md). To make "type all the things!" particularly easy, Lore allows you to **create ad-hoc open envelope types when defining classes:**

  ```
  class Position {
    x: Real as XCoord
    y: Real as YCoord
    z: Real as ZCoord
  }
  ```

  Looks stupid? Wait until you accidentally pass an x-coordinate as a y-coordinate in C++.

  Each envelope type becomes part of the namespace of the class, so the code above implicitly declares the following:

  ```
  namespace Position {
    envelope XCoord(Real)
    envelope YCoord(Real)
    envelope ZCoord(Real)
  }
  ```

  However, the ad-hoc definition has the additional advantage that **envelope types are constructed internally**. Take the following example:

  ```
  class Account {
    id: Int as Id
    name: String as Name
    score: Real as Score
  }
  val jeremy = Account(1, "Jeremy", 15.37)
  > jeremy.id : Account.Id
  > jeremy.name : Account.Name
  > jeremy.score : Account.Score
  ```

  As you can see, the constructor takes the underlying values as arguments and doesn't require any envelope boilerplate.



### Entities & Components

An **entity** is a class associated with one or more components. In addition to property definitions permitted in classes, an entity type may also define components:

```
entity E {
  x: A
  component C1
  component C2
  y: B
}
```

A component *must* be a **class or envelope**. This requirement is simple when we consider that components must also be **unnamed**, because component types such as `+C1` don't carry name information. Thus, the name of a component is the same as the name of its type. Only one component of the same type may be part of an entity.

Here, the type `E` **has** a component `C1`. The component can be **accessed** like an attribute, `e.C1`, with the type name as the accessor name. 

When a component `C1` is declared like this, the type `E` satisfies the typing `E & +C1`. The `+C1` is read as **"has C1"** and is a type *describing the entity*, not the component. For example, when we have a variable `e: +C1`, `e` is not C1 itself but rather the entity with a component of type `C1`.

At run-time, `E` might actually be a type `E & +C3` given `C3 < C1`, if a value of `C3` was assigned as a component as opposed to a value of `C1`. This has profound implications for **multiple dispatch:** Entities are dispatched based on their *actual* type and the *types of their components at run-time*.

Once assigned to an entity, a component cannot be replaced or removed: **components are immutable**. Note that, while the *reference* is immutable, the component *itself* does not have to be immutable. You can, of course, still model changing state in Lore, but that change needs to be applied inside the component, not by replacing a component.

(**TODO:** Consider mutable components for cases where an immutable class needs to be a component? In general, it would be possible to replace components. The only time we need immutability is when we want to override a component in a subclass.)

##### Instantiation

Entities are **instantiated** like classes, with the simple addition that component declarations are also added as parameters in their order of declaration. For example, the entity declard above would have the following default constructor:

```
E(x: A, c1: C1, c2: C2, y: B)
```

In fact, components are treated exactly like properties when constructors are concerned. All the same features and rules apply with entities as they do with classes.

##### Inheritance

An entity may also inherit from another entity or class. The case of **entity inheritance** is particularly interesting, since we can override component definitions:

```
entity Skeleton extends Monster {
  component PoisonImmunity overrides Immunity
  component Bones
}

class Position2D extends Position3D {
  // redefine z as always 0
}

entity Entity2D extends Entity3D {
  component Position2D overrides Position3D
}
```

This is specifically possible because *component properties are immutable*. The parent class cannot reassign its own components, so we are free to require more specific types for sub-entities.

##### Ownership

Some components may **depend** on other components. For example, an AI component may rely on a position component. We want to provide a native way to deal with such dependencies.

When declaring a class, you can declare that the class viewed as a component must be **owned** by an entity of a specific type. This effectively puts a constraint on the type of the component's entity:

```
// Require an entity that gets displayed via a sprite to also have a position.
class Sprite owned by +Position { ... }
```

This constraint is *only relevant for component declarations*. It does not in any way affect the ability to create instances of the declared class. We **guarantee at compile-time** that an entity declaring a component can in fact own it; if not, we throw a compilation error. The check simply tests whether the type bounds given by the component are compatible with the entity.

An ownership restriction may be **any kind of type**. We don't guarantee that any entity can satisfy this type, but we don't place any systematic restraints on the type. In general, you will want to restrict ownership for two use cases:

- You need to **access another component of the entity**. You wouldn't be able to implement this component without access to the other component.
- You want to restrict a component to a **specific entity type**. For example, you could restrict a component `Loot` to the `Monster` entity type.

Having declared an ownership constraint, a variable of type `+Sprite` will also give you **access to the owner's types:**

```
function draw(e: +Sprite) = {
  draw(e.Sprite.image, e.Position)
}
```

Even though we have only declared the entity to have the Sprite component, as the ownership of a Sprite is restricted to entities that also have a Position component, we can be sure that `e` **also has a Position component**. Lore recognizes this and allows you to access that other component.

Ownership restrictions are passed down via **inheritance**. A subclass must keep the current restrictions.

- **TODO:** Can subclasses add new restrictions? I think this would lead to runtime errors… Like this:

  ```
  class A
  class A1 extends A
  class B owned by +A
  class B1 extends B owned by +A1
  
  entity E {
    component A
    component B
  }
  
  function create(): E = {
    const a = A()
    const b: B = B1()
    // At this point, b is not obviously B1, as it could have come
    // from somewher else entirely. This might be obvious to the
    // compiler, but not in the more complicated circumstances.
    E(a, b)
  }
  ```

  All checks seem to pass, but because B1 narrows the ownership restriction, B1 is *not* owned by an entity `+A1`. Allowing subclasses to narrow this restriction would be very useful, but is sadly not feasible in this way. We will need to contemplate this further to perhaps find a better solution.

Note that one object can be a component of **multiple entities**. For example, you could share a health state between two bosses in a boss fight. We don't want to remove this freedom and so Lore requires diligence of the programmer when it comes to component instantiation.

###### Example

Let's see another example:

```
class LemmingAI owned by +Position { }

function walk(entity: +LemmingAI) = {
  // Always forward! (To the right in a sidescrolling game.)
  entity.Position.translateX(1)
}
```

##### Adding Multiple Components of the Same Type

Suppose we have a `Wheel` and want to add four of them to a `Car`. You can't simply add four components of the same type. The solution would be to use some kind of wrapper type. Both of these possible representations are illegal as components: `(Wheel, Wheel, Wheel, Wheel)` and `[Wheel]`. In fact, you will need to create a new class, for example named `WheelSet`, which holds the wheels however it wants. You can then declare it as a component and access it via `e.WheelSet`.

##### Post-MVL Extensions

- Compare to property/class extensions: **Visibility**, **default** values, **derived** components (excluding computed components).

- Every entity defines a **list of components** which can be filtered and iterated over.

- **Importing Component Properties:** We could support importing properties from a component into the entity namespace. Properties x, y, and z would be available for use just as if they were directly declared within the entity.

  ```
  entity Entity {
    component Position import {x, y, z}
  }
  ```

  - One issue with this is that this syntactic sugar only applies when the **entity type is available directly**, obviously. If we define a function over `e: +Position`, we wouldn't be able to access `x` directly from `e` (`e.x`), but would still have to write `e.Position.x`. Only when we declare `e: Entity` can we write `e.x`.
  
- **Component life cycle functions:** We can add an action `onAttached(c: C, e: +C)` (in the Lore namespace) that is called when a component `C` has been attached to an entity `+C`. Its default implementation would be for the type `Any, +Any` and simply do nothing, so it would then be possible to specialize the function for any kind of component type, without the *need* to do so.

  ```
  action onAttached(component: Any, entity: +Any) {
    // Do nothing.
  }
  
  action onAttached(a: A, entity: +A) {
    // A has been attached to an arbitrary entity.
  }
  
  action onAttached(a: A, entity: +A & +B) {
    // One special case for any entity that also has a B component.
  }
  
  action onAttached(a: A, entity: SomeEntity) {
    // Another implementation that requires the entity to be of some
    // concrete entity type.
  }
  ```

  We need the **first parameter** since we want to associate `onAttached` with one specific component. If we didn't have this first parameter, we'd essentially define `onAttached` for multiple components, such as `entity: +A & +B`. Without the first parameter, there is no way to differentiate whether this `onAttached` should belong to A or B.