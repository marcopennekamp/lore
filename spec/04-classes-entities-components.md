# Classes, Entities, and Components

[Previous File](03-multi-functions.md) [Next File](05-expressions.md)

In this document, we consider **classes, entities, and components**.

While classes are hugely important in Lore, the true focus of the language lies on **entities and components**. A component, in short, is a set of properties that is *also* part of a larger entity. It is thus not the component itself which brings the flexibility, but the **combination of multiple components** in one entity. The novelty that I believe Lore brings to the table is that we can define functions over arbitrary combinations of components. We could define a function over a combination `+Position & +HealthState` that is then usable by *all* entities that have these two components. This allows a programmer to separate and mix data in such a way that maximum flexibility can be achieved—I believe this is especially useful for game development, but could be equally useful in general purpose contexts. My job as a language designer is to give you the tools so *you* can figure out the useful contexts.

**A modest list of TODOs:**

- **TODO:** What about attaching components at run-time? We need that feature, but probably not for the first language version. This should be developed hand-in-hand with dynamic specialization.

- **TODO:** How do we create classes that override component types? In general, class property types can't be overridden in subclasses, because properties can both be set and gotten by the parent class. But: Shouldn't classes be covariant in the components they define, as components cannot be swapped out, only set with the constructor? So if a type `Entity3D` has a component `Position3D`, shouldn't a subtype `Entity2D` be able to have a `Position2D`?

- **TODO:** We can make *immutable* properties in general overridable.

- **Idea:** Add a Record data type (or maybe named case class, simple class, struct, etc.), which is akin to case classes in Scala. The user will be able to pattern-match values of this type, which is not possible with classes. A record can't have components, but will be able to become a component of some entity.

  ```
  record Position(x: Real, y: Real, z: Real) {
    derived isOrigin: Boolean = x == y && y == z && z == 0.0
  }
  ```

- **TODO:** Component subtyping leads to a diamond problem. Consider an entity with two components: `CelsiusTemperature` and `FahrenheitTemperature`. Which component is chosen if we want to assign the entity to a variable of type `+Temperature`? This hints that we need to exclude whole hierarchies of types when we consider which components can be mutually part of the same entity.

  - Going further, will we get problems with `Any`? What happens when we assign an entity to `+Any`? (Ouch.)



### Classes

A **class** is a nominal data type defining a set of properties and constructors. Class instances are called objects. The syntax is as follows:

```
class C {
  a: A
  mut b: B
  // constructor syntax defined later
}
const c = C(a, b)
```

A **property** is either *immutable* (denoted without a keyword) or *mutable* (denoted `mut`). Only mutable properties can be modified after the object has been constructed. Properties are **accessed** via the dot notation. See [05-expressions](05-expressions.md).

A **constructor** is a function that creates an instance of the class it's declared within. Constructors are special in that they must be used to create a new instance of a class. There is no other way to define instantiation.

A class can be **abstract:**

```
abstract class Score { }
function points(score: Score) = ...
```

###### Example

```
class Position {
  x: Real
  y: Real
  z: Real
  // Implicit default constructor: Position(x: Real, y: Real, z: Real)
}
```

##### Inheritance

A class `A` may **inherit** from another class `B`. This allows `A` to inherit all properties of `B` and also puts `A` into a subtyping relation `A < B`.

```
class A extends B
```

**Constraints:**

- **Classes** may not inherit from **entities**.

##### Constructors

Constructors are special functions which can use the **construct** statement. The construct statement takes as arguments all of the class's properties in their order of declaration. For example, the declaration in the introduction would have the associated construct statement `construct(a, b)` for `a: A` and `b: A`. This statement simply assign the given arguments to the properties and thus creates an object. Ultimately, this statement is the only way to *create* a new instance.

Every class has one **default constructor**. If we have a class named `A`, this constructor can be accessed with `A(...)`. This constructor is generated by default, where its parameters are all the class's local properties followed by the arguments of the supertype's default constructor. It can easily be overridden.

Let's look at how we can **define constructors:**

```
class Position {
  // ...
  
  // The following is the default constructor as it is generated.
  Position(x: Real, y: Real, z: Real) {
    construct(x, y, z)
  }
  
  // Note how our constructor syntax doesn't include the equals
  // sign known from function definitions.
  from2D(x: Real, y: Real) {
    this(x, y, 0)
  }
  
  from1D(x: Real) {
    this.from2D(x, 0)
  }
}

Position.from2D(1.0, 1.5) // => Position(1.0, 1.5, 0.0)
```

All non-default constructors have to be **named**. Inside the constructor scope, `this` refers to the default constructor, while `this.from2D` would refer to the constructor named `from2D`. Outside the constructor scope, `Position(...)` refers to the default constructor, while `Position.from2D(…)` refers to the named constructor.

Every constructor has to **terminate** in a `this` or `construct` statement, either deferring to another constructor or constructing the instance. The call must be the last statement in the block, at the top level. (**TODO:** Alternatively, we could throw a run-time error if an object isn't correctly constructed, which would allow for more flexibility in constructor definitions.)

**Construction, not initialization:** A constructor does not have access to object properties or the new instance. A constructor is supposed to *construct* an instance, not *initialize* it. If a class is so complex that it needs to be initialized after a value has been constructed, you should require a separate initialization step. Of course, you can perform arbitrary calculations before the `this`/`construct` call, but you'll have to work with the attributes.

###### Throwing Super into the Mix

Things get slightly more complicated when we consider **superclasses**. For the sake of flexibility, we want to allow calling any superclass constructor in combination with any class constructor. This is possible with an extension to the `construct` statement:

```
class Character {
  name: String
  
  // Just for illustration purposes.
  Character(name: String) {
    construct(name) 
  }
  
  fromArchetype(archetype: Archetype) {
    // We defer to the default constructor.
    this(archetype.name) 
  }
}

class Player extends Character {
  money: Real
  
  // Again, just for illustration.
  Player(money: Real, name: String) {
    construct(money) with super(name)
  }
  
  // Make sure we call the fromArchetype constructor of Character.
  fromArchetype(archetype: Archetype) {
    construct(0) with super.fromArchetype(archetype)
  }
}
```

We can add a `with super(...)` to the construct statement which allows us to **call any superclass constructor**.

##### Parametric Types

Just like functions, classes can be **parameterized over types:**

```
class Either  {
  
}

Tree(A, B)

class Tree A {
  
}
```

**TODO:** Can we support components declared via a type parameter? This would be super useful, but could mess with existing constraints.

##### Post-MVL Extensions

- **Visibility declarations** like public, private, protected, etc. Whatever we need.

  - It should be possible to make the **default constructor private** so that class users have to use one of the named constructors.

- **Default values** for properties.

- Easy **getters and setters** for properties.

- **Derived properties** are properties that depend on other properties and can't be passed through the constructor. By default, a `derived` property is computed once after all non-derived properties and derived properties ordered before the given property have been initialized. You can also declare a `computed` property that is recomputed every time it is accessed. (Computed may not be the best term for this, however.)

  While derived properties could also be implemented by multi-functions, they provide the ability to define a property about the data that is **invariant** and can't be changed through function specialisation.

  ```
  class RightTriangle {
    a: Real
    b: Real
    derived c: Real = sqrt(pow(a, 2) * pow(b, 2))
  }
  ```

- **Syntactic sugar for functions**, as seen below. These functions would simply be immutable properties that hold an anonymous function. This can be useful in some specific cases, but could also lead to bad code style or confused new language users if these kinds of functions are erroneously preferred over multi-functions. Maybe we shouldn't make it easy to declare such functions.

  ```
  class C {
    function f(a: A): B = ...
    // is the same as
    f: A => B = { a => ... }
  }
  ```

- Some kind of companion object as known from Scala? Or rather **companion namespaces**? (Also see the `namespace Position` declaration in the example below.)

- Allow classes to extend **label types:**

  ```
  class A is Saveable and Sorted
  ```

- **Ad-hoc envelope types:** Lore will support [envelope types](types.md). To make "type all the things!" particularly easy, Lore allows you to **create ad-hoc open envelope types when defining classes:**

  ```
  class Position {
    x: Real as XCoord
    y: Real as YCoord
    z: Real as ZCoord
  }
  ```

  Looks stupid? Wait until you accidentally pass an x-coordinate as a y-coordinate in C++.

  Each envelope type becomes part of the namespace of the class, so the code above implicitly declares the following:

  ```
  namespace Position {
    envelope XCoord(Real)
    envelope YCoord(Real)
    envelope ZCoord(Real)
  }
  ```

  However, the ad-hoc definition has the additional advantage that **envelope types are constructed internally**. Take the following example:

  ```
  class Account {
    id: Int as Id
    name: String as Name
    score: Real as Score
  }
  val jeremy = Account(1, "Jeremy", 15.37)
  > jeremy.id : Account.Id
  > jeremy.name : Account.Name
  > jeremy.score : Account.Score
  ```

  As you can see, the constructor takes the underlying values as arguments and doesn't require any envelope boilerplate.



### Entities & Components

An **entity** is a class associated with one or more components. In addition to property definitions permitted in classes, an entity type may also define components:

```
entity E {
  x: A
  component C1
  component C2
  y: B
}
```

A component *must* be a **class or envelope**. This requirement is simple when we consider that components must also be **unnamed**, because component types such as `+C1` don't carry name information. Thus, the name of a component is the same as the name of its type. Only one component of the same type may be part of an entity.

Here, the type `E` **has** a component `C1`. The component can be **accessed** like an attribute, `e.C1`, with the type name as the accessor name. 

When a component `C1` is declared like this, the type `E` satisfies the typing `E & +C1`. The `+C1` is read as **"has C1"** and is a type *describing the entity*, not the component. For example, when we have a variable `e: +C1`, `e` is *not* C1 itself but rather the entity with a component of type `C1`.

At run-time, `E` might actually be a type `E & +C3` given `C3 < C1`, if a value of `C3` was assigned as a component as opposed to a value of `C1`. This has profound implications for **multiple dispatch:** Entities are dispatched based on their *actual* type and the *types of their components at run-time*.

Once assigned to an entity, a component cannot be replaced or removed: **components are immutable**. Note that, while the *reference* is immutable, the component *itself* does not have to be immutable. You can, of course, still model changing state in Lore, but that change needs to be applied inside the component, not by replacing a component.

(**TODO:** Consider mutable components for cases where an immutable class needs to be a component? In general, it would be possible to replace components. The only time we need immutability is when we want to override a component in a subclass.)

##### Instantiation

Entities are **instantiated** like classes, with the simple addition that component declarations are also added as parameters in their order of declaration. For example, the entity declared above would have the following default constructor:

```
E(x: A, c1: C1, c2: C2, y: B)
```

In fact, components are treated exactly like properties when constructors are concerned. All the same features and rules apply with entities as they do with classes.

##### Inheritance

An entity may also inherit from another entity or class. The case of **entity inheritance** is particularly interesting, since we can override component definitions:

```
entity Skeleton extends Monster {
  component PoisonImmunity overrides Immunity
  component Bones
}

class Position2D extends Position3D {
  // redefine z as always 0
}

entity Entity2D extends Entity3D {
  component Position2D overrides Position3D
}
```

This is specifically possible because *component properties are immutable*. The parent class cannot reassign its own components, so we are free to require more specific types for sub-entities.

##### Component Type Restrictions

The freedom with which we allow subtyping of component types has a few **implications**. Say we have an entity type `E & C2` with `C1 < C2 < C3`. We could assign a value of either `C1` or `C2` to the entity. This already leads to a problem when we consider the compilation process:

```
entity E1 {
  component C1
}

entity E2 {
  component C2
}

action f(e: +C2) {
  e.C2
}
```

In the example above, assume that `C1` of `E1` is named `C1` in the resulting target code. How do we get `C1` through a property access of `C2`? This requires us to **resolve component values dynamically at run-time** if we try to access a subtypeable component `C2` through a generic component type. A similar problem arises with overridden components, by the way: we have to add a bridge from the overridden component to the overriding component.

Consider another problem: since `C2 < C3`, we should be able to **access** `C1` of `E1` via a variable of type `+C3`:

```
action f2(e: +C3) {
  e.C3 // If e has type E1, this should be a C1.
}
```

This is immediately useful, of course. But `C3` **wasn't even declared** in either `E1` or `E2`. This leads to the following awkwardness:

```
abstract class C
class CA extends C
class CB extends C

entity E {
  component CA
  component CB
}

action f(e: +C) {
  e.C // WELL THAT'S A PROBLEM.
}
```

We don't know whether `e.C` refers to `CA` or `CB`. Well, in fact, it refers to *both*. But we don't know that `e` is `E` in `f`. We just know that *some* entity has a component of type `C`. This means we have **two options:**

1. Any component access **returns a list**.
2. Any two components defined in an entity **must not share a superclass**.

The first option would make components effectively unusable. It is rarely desirable to have to always handle lists when we want to operate on components that should be standalone instances. Hence, we choose the **second option**.

If no components share a superclass (`Any` does not count, since it is not a class), we can **always decide** which component belongs to a given component type `+C`. The downside is that we cannot have two components sharing a superclass, such as:

```
abstract class Stat
class Strength extends Stat
class Dexterity extends Stat

entity Hero {
  // Does not compile: Strength and Dexterity share a superclass.
  component Strength
  component Dexterity
}
```

But of course, we can always **rewrite the entity** in a way that allows us to implement the desired design. Consider the following example. We lose a little bit of flexibility, but we gain flexibility by being able to access components by their supertype. 

```
class StatRepository {
  strength: Strength
  dexterity: Dexterity
}

entity Hero {
  component StatRepository
}
```

Luckily, by the way, **`+Any`** is not a valid type, since `Any` is not a class. So we don't shoot ourselves in the foot by disallowing the full class hierarchy, only the subtree with root `C` being a direct subtype of `Any`.

Since component types (`+C`) are restricted to classes, we do not have the same issue with **label types** (or potential future traits, interfaces, and so on). This means that we *can* have two components that have the same label type. We can *also* support an operation that gives us a list of components that have a specific label type. If an access like `e.C3` was going to return a list, we wouldn't even have to introduce the subtype-supertype restriction. 

##### Ownership

Some components may **depend** on other components. For example, an AI component may rely on a position component. We want to provide a native way to deal with such dependencies.

When declaring a class, you can declare that the class viewed as a component must be **owned** by an entity of a specific type. This effectively puts a constraint on the type of the component's entity:

```
// Require an entity that gets displayed via a sprite to also have a position.
class Sprite owned by +Position { ... }
```

This constraint is *only relevant for component declarations*. It does not in any way affect the ability to create instances of the declared class. We **guarantee at compile-time** that an entity declaring a component can in fact own it; if not, we throw a compilation error. The check simply tests whether the type bounds given by the component are compatible with the entity.

An ownership restriction may be **any kind of type**. We don't guarantee that any entity can satisfy this type, but we don't place any systematic restraints on the type. In general, you will want to restrict ownership for two use cases:

- You need to **access another component of the entity**. You wouldn't be able to implement this component without access to the other component.
- You want to restrict a component to a **specific entity type**. For example, you could restrict a component `Loot` to the `Monster` entity type.

Having declared an ownership constraint, a variable of type `+Sprite` will also give you **access to the owner's types:**

```
function draw(e: +Sprite) = {
  draw(e.Sprite.image, e.Position)
}
```

Even though we have only declared the entity to have the Sprite component, as the ownership of a Sprite is restricted to entities that also have a Position component, we can be sure that `e` **also has a Position component**. Lore recognizes this and allows you to access that other component.

Ownership restrictions are passed down via **inheritance**. A subclass may keep the current restrictions or **subtype them**. This is not fully type-safe at compile-time. For example, consider this piece of code:

```
class A
class A1 extends A
class B owned by +A
class B1 extends B owned by +A1

entity E {
  component A
  component B
}

function create(): E = {
  const a = A()
  const b: B = B1()
  E(a, b)
}
```

The compiler approves this layout, but because `B1` narrows the ownership restriction, `B1` is *not* owned by an entity `+A1`. It is clear that this code cannot go ahead as is. The question is when we throw the error. We have two ways to go about this:

- We could make owned-by declarations **invariant**. That is, when an owned-by type has been declared, it has to be replicated across the whole inheritance hierarchy. I don't see another (straight-forward) way to solve this while still keeping component subtyping intact. We would either have to get rid of the ability to use subclasses as components (e.g. use `B1` in place of `B`), or we would have to get rid of the ability to subtype ownership restrictions.

- What do we do if we can't check it at compile-time? **We check it at run-time!** That is, instead of giving compile-time guarantees that ownership restrictions hold, we check ownership each time an entity is instantiated. At compile-time, we only check ownership for the declared component types. This means that ownership won't be arbitrary. **We will still check what we can at compile-time.**

  At run-time, we get down into the actual component types, that is, potentially their subtypes. Components being immutable, we only have to check this when an entity is instantiated, so there are, I feel, few enough points of failure.

In the end we have to choose between safety and flexibility. I believe Lore should be flexible rather than safe; multi-functions aren't perfectly safe, either. For example, we always run the risk to arrive at ambiguous calls at run-time, which might never have been caught at compile-time. Instantiating entities is in the same rough category of run-time errors. Hence, we have chosen the second option, to **allow subtyping owned-by types**, with a **hybrid checking model**.

Besides, I believe this will follow the **actual usage patterns** of the language. A constellation such as the example above could be very common. One might desire to have different kinds of `Position` components tied to different kinds of `Speed` components. If we don't allow subtyping owned-by types, that will not stop Lore users who *want* to subtype owned-by types. And so they might resort to a less idiomatic solution such as type-casting, or throwing runtime exceptions (once we actually add exceptions) from one branch of multiple dispatch, that is, the branch that is not supposed to exist.

Note that one object can be a component of **multiple entities**. For example, you could share a health state between two bosses in a boss fight. We don't want to remove this freedom and so Lore asks extra diligence of the programmer when it comes to component instantiation.

###### Example

Let's see another example:

```
class LemmingAI extends AI owned by +Position

function walk(entity: +LemmingAI) = {
  // Always forward! (To the right in a sidescrolling game.)
  entity.Position.translateX(1)
}
```

##### Adding Multiple Components of the Same Type

Suppose we have a `Wheel` and want to add four of them to a `Car`. You can't simply add four components of the same type. The solution would be to use some kind of wrapper type. Both of these possible representations are illegal as components: `(Wheel, Wheel, Wheel, Wheel)` and `[Wheel]`. In fact, you will need to create a new class, for example named `WheelSet`, which holds the wheels however it wants. You can then declare it as a component and access it via `e.WheelSet`.

##### Post-MVL Extensions

- Compare to property/class extensions: **Visibility**, **default** values, **derived** components (excluding computed components).

- Every entity defines a **list of components** which can be filtered and iterated over.

- **Importing Component Properties:** We could support importing properties from a component into the entity namespace. Properties x, y, and z would be available for use just as if they were directly declared within the entity.

  ```
  entity Entity {
    component Position import {x, y, z}
  }
  ```

  - One issue with this is that this syntactic sugar only applies when the **entity type is available directly**, obviously. If we define a function over `e: +Position`, we wouldn't be able to access `x` directly from `e` (`e.x`), but would still have to write `e.Position.x`. Only when we declare `e: Entity` can we write `e.x`.
  
- **Component life cycle functions:** We can add an action `onAttached(c: C, e: +C)` (in the Lore namespace) that is called when a component `C` has been attached to an entity `+C`. Its default implementation would be for the type `Any, +Any` and simply do nothing, so it would then be possible to specialize the function for any kind of component type, without the *need* to do so.

  ```
  action onAttached(component: Any, entity: +Any) {
    // Do nothing.
  }
  
  action onAttached(a: A, entity: +A) {
    // A has been attached to an arbitrary entity.
  }
  
  action onAttached(a: A, entity: +A & +B) {
    // One special case for any entity that also has a B component.
  }
  
  action onAttached(a: A, entity: SomeEntity) {
    // Another implementation that requires the entity to be of some
    // concrete entity type.
  }
  ```

  We need the **first parameter** since we want to associate `onAttached` with one specific component. If we didn't have this first parameter, we'd essentially define `onAttached` for multiple components, such as `entity: +A & +B`. Without the first parameter, there is no way to differentiate whether this `onAttached` should belong to A or B.